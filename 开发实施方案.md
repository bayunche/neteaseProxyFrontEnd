# ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨ - å¼€å‘å®æ–½æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è§ˆ

åŸºäºè¯¦ç»†æŠ€æœ¯è®¾è®¡ï¼Œæœ¬å¼€å‘æ–¹æ¡ˆå°†åˆ†8ä¸ªé˜¶æ®µã€16å‘¨æ—¶é—´å®Œæˆç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨çš„å®Œæ•´å¼€å‘ã€‚æ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„ç›®æ ‡ã€å…·ä½“çš„å®æ–½æ­¥éª¤å’ŒéªŒæ”¶æ ‡å‡†ã€‚

---

## ğŸš€ é˜¶æ®µ1: é¡¹ç›®åŸºç¡€è®¾æ–½æ­å»º (ç¬¬1-2å‘¨)

### 1.1 ç¯å¢ƒå‡†å¤‡ä¸é¡¹ç›®åˆå§‹åŒ–

#### æ­¥éª¤1.1.1: å¼€å‘ç¯å¢ƒé…ç½®
```bash
# 1. ç¡®ä¿Node.jsç‰ˆæœ¬ >= 16
node --version

# 2. åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir netease-music-player
cd netease-music-player

# 3. åˆå§‹åŒ–Viteé¡¹ç›®
npm create vite@latest . -- --template react-ts

# 4. å®‰è£…åŸºç¡€ä¾èµ–
npm install

# 5. å®‰è£…å¿…è¦çš„å¼€å‘ä¾èµ–
npm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser
npm install -D prettier eslint-config-prettier eslint-plugin-prettier
npm install -D @types/node
npm install -D husky lint-staged
```

#### æ­¥éª¤1.1.2: é¡¹ç›®ç»“æ„è®¾ç½®
```bash
# åˆ›å»ºæ ‡å‡†ç›®å½•ç»“æ„
mkdir -p src/{components,pages,hooks,services,stores,types,utils,assets}
mkdir -p src/components/{common,player,search,playlist}
mkdir -p src/services/{audio,api,cache,storage}
mkdir -p public/{icons,images}
```

**é¡¹ç›®ç›®å½•ç»“æ„ï¼š**
```
src/
â”œâ”€â”€ components/           # ç»„ä»¶ç›®å½•
â”‚   â”œâ”€â”€ common/          # é€šç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ player/          # æ’­æ”¾å™¨ç»„ä»¶
â”‚   â”œâ”€â”€ search/          # æœç´¢ç»„ä»¶
â”‚   â””â”€â”€ playlist/        # æ’­æ”¾åˆ—è¡¨ç»„ä»¶
â”œâ”€â”€ pages/               # é¡µé¢ç»„ä»¶
â”œâ”€â”€ hooks/               # è‡ªå®šä¹‰Hook
â”œâ”€â”€ services/            # æœåŠ¡å±‚
â”‚   â”œâ”€â”€ audio/           # éŸ³é¢‘æœåŠ¡
â”‚   â”œâ”€â”€ api/             # APIæœåŠ¡
â”‚   â”œâ”€â”€ cache/           # ç¼“å­˜æœåŠ¡
â”‚   â””â”€â”€ storage/         # å­˜å‚¨æœåŠ¡
â”œâ”€â”€ stores/              # çŠ¶æ€ç®¡ç†
â”œâ”€â”€ types/               # TypeScriptç±»å‹å®šä¹‰
â”œâ”€â”€ utils/               # å·¥å…·å‡½æ•°
â””â”€â”€ assets/              # é™æ€èµ„æº
```

### 1.2 å¼€å‘å·¥å…·é…ç½®

#### æ­¥éª¤1.2.1: ESLinté…ç½®
åˆ›å»º `.eslintrc.js`:
```javascript
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
    'prettier'
  ],
  ignorePatterns: ['dist', '.eslintrc.js'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    'prefer-const': 'error',
  },
}
```

#### æ­¥éª¤1.2.2: Prettieré…ç½®
åˆ›å»º `.prettierrc`:
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
```

#### æ­¥éª¤1.2.3: Gité…ç½®
```bash
# åˆå§‹åŒ–Git
git init

# åˆ›å»º.gitignore
cat > .gitignore << EOF
# Dependencies
node_modules/

# Production builds
dist/
build/

# Environment variables
.env
.env.local
.env.production

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Cache
.cache/
.parcel-cache/
EOF

# é…ç½®Huskyå’Œlint-staged
npx husky-init
npm pkg set scripts.prepare="husky install"
npm run prepare

# æ·»åŠ pre-commit hook
npx husky add .husky/pre-commit "npx lint-staged"

# é…ç½®lint-staged
npm pkg set lint-staged."{\"*.{ts,tsx}\":\"eslint --fix\",\"*.{ts,tsx,css,md}\":\"prettier --write\"}"
```

### 1.3 åŸºç¡€ä¾èµ–å®‰è£…

#### æ­¥éª¤1.3.1: æ ¸å¿ƒä¾èµ–å®‰è£…
```bash
# çŠ¶æ€ç®¡ç†
npm install zustand

# è·¯ç”±
npm install react-router-dom

# æ ·å¼æ¡†æ¶
npm install tailwindcss postcss autoprefixer
npm install -D @tailwindcss/typography

# UIç»„ä»¶åº“åŸºç¡€
npm install lucide-react
npm install framer-motion

# å·¥å…·åº“
npm install clsx
npm install date-fns
```

#### æ­¥éª¤1.3.2: Tailwind CSSé…ç½®
```bash
# åˆå§‹åŒ–Tailwind
npx tailwindcss init -p

# é…ç½®tailwind.config.js
cat > tailwind.config.js << 'EOF'
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#fef2f2',
          500: '#ef4444',
          600: '#dc2626',
          700: '#b91c1c',
          900: '#7f1d1d',
        },
        netease: '#C62D42',
      },
      fontFamily: {
        sans: ['PingFang SC', 'Microsoft YaHei', 'sans-serif'],
      },
    },
  },
  plugins: [],
  darkMode: 'class',
}
EOF
```

#### æ­¥éª¤1.3.3: é…ç½®CSSå…¥å£æ–‡ä»¶
æ›´æ–° `src/index.css`:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    box-sizing: border-box;
  }
  
  html {
    font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
  }
  
  body {
    margin: 0;
    padding: 0;
    background-color: #f5f5f7;
  }
}

@layer components {
  .btn-primary {
    @apply bg-netease text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors;
  }
  
  .card {
    @apply bg-white rounded-lg shadow-sm border border-gray-100;
  }
}
```

### 1.4 åŸºç¡€ç±»å‹å®šä¹‰

#### æ­¥éª¤1.4.1: åˆ›å»ºæ ¸å¿ƒç±»å‹å®šä¹‰
åˆ›å»º `src/types/index.ts`:
```typescript
// éŸ³ä¹æºæšä¸¾
export enum MusicSource {
  QQ_MUSIC = 'qq',
  KUGOU = 'kugou',
  MIGU = 'migu',
  LOCAL = 'local'
}

// éŸ³è´¨æšä¸¾
export enum AudioQuality {
  LOW = '128k',
  STANDARD = '192k',
  HIGH = '320k',
  LOSSLESS = 'flac'
}

// æ’­æ”¾æ¨¡å¼æšä¸¾
export enum PlayMode {
  SEQUENCE = 'sequence',
  RANDOM = 'random',
  SINGLE = 'single',
  LIST_LOOP = 'list_loop'
}

// æ­Œæ›²æ¥å£
export interface Song {
  id: string;
  title: string;
  artist: string;
  album: string;
  duration: number;
  coverUrl: string;
  audioUrl?: string;
  source: MusicSource;
  quality: AudioQuality;
  lyricId?: string;
}

// ä¸“è¾‘æ¥å£
export interface Album {
  id: string;
  title: string;
  artist: string;
  coverUrl: string;
  releaseDate: Date;
  songs: Song[];
  source: MusicSource;
}

// è‰ºæœ¯å®¶æ¥å£
export interface Artist {
  id: string;
  name: string;
  avatarUrl: string;
  description: string;
  albums: Album[];
  topSongs: Song[];
  source: MusicSource;
}

// æ’­æ”¾åˆ—è¡¨æ¥å£
export interface Playlist {
  id: string;
  title: string;
  description: string;
  coverUrl: string;
  creator: string;
  songs: Song[];
  isPublic: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// æ­Œè¯æ¥å£
export interface LyricLine {
  time: number;
  text: string;
  translation?: string;
}

export interface Lyrics {
  songId: string;
  lines: LyricLine[];
  offset: number;
}

// æœç´¢ç»“æœæ¥å£
export interface SearchResult {
  songs: Song[];
  albums: Album[];
  artists: Artist[];
  playlists: Playlist[];
  total: number;
  page: number;
  pageSize: number;
}
```

### 1.5 åŸºç¡€å·¥å…·å‡½æ•°

#### æ­¥éª¤1.5.1: åˆ›å»ºå·¥å…·å‡½æ•°
åˆ›å»º `src/utils/index.ts`:
```typescript
/**
 * æ ¼å¼åŒ–æ—¶é—´ (ç§’ -> mm:ss)
 */
export function formatTime(seconds: number): string {
  if (!seconds || seconds < 0) return '00:00';
  
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B';
  
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * é˜²æŠ–å‡½æ•°
 */
export function debounce<T extends (...args: any[]) => void>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

/**
 * èŠ‚æµå‡½æ•°
 */
export function throttle<T extends (...args: any[]) => void>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

/**
 * ç”Ÿæˆå”¯ä¸€ID
 */
export function generateId(): string {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

/**
 * æ·±åº¦åˆå¹¶å¯¹è±¡
 */
export function deepMerge<T>(target: T, source: Partial<T>): T {
  const result = { ...target };
  
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object') {
      result[key] = deepMerge(result[key], source[key]);
    } else {
      result[key] = source[key] as T[Extract<keyof T, string>];
    }
  }
  
  return result;
}

/**
 * ç±»ååˆå¹¶å·¥å…· (ç±»ä¼¼clsx)
 */
export function cn(...classes: (string | undefined | null | false)[]): string {
  return classes.filter(Boolean).join(' ');
}
```

### 1.6 éªŒæ”¶æ ‡å‡†

#### é˜¶æ®µ1å®Œæˆæ£€æŸ¥æ¸…å•ï¼š
- [ ] âœ… é¡¹ç›®æˆåŠŸåˆå§‹åŒ–ï¼Œå¯ä»¥è¿è¡Œ `npm run dev`
- [ ] âœ… ESLintå’ŒPrettieré…ç½®æ­£ç¡®ï¼Œä»£ç æ ¼å¼åŒ–æ­£å¸¸
- [ ] âœ… Gité…ç½®å®Œæˆï¼Œpre-commit hookå·¥ä½œæ­£å¸¸
- [ ] âœ… Tailwind CSSé…ç½®æ­£ç¡®ï¼Œæ ·å¼å¯ä»¥æ­£å¸¸ä½¿ç”¨
- [ ] âœ… åŸºç¡€ç±»å‹å®šä¹‰å®Œæ•´ï¼Œç¬¦åˆè®¾è®¡è§„èŒƒ
- [ ] âœ… å·¥å…·å‡½æ•°æµ‹è¯•é€šè¿‡
- [ ] âœ… é¡¹ç›®ç›®å½•ç»“æ„è§„èŒƒï¼Œç¬¦åˆçº¦å®š

---

## ğŸµ é˜¶æ®µ2: æ ¸å¿ƒéŸ³é¢‘å¼•æ“å¼€å‘ (ç¬¬3-4å‘¨)

### 2.1 éŸ³é¢‘å¼•æ“æ ¸å¿ƒæ¶æ„

#### æ­¥éª¤2.1.1: åˆ›å»ºéŸ³é¢‘å¼•æ“æ¥å£
åˆ›å»º `src/services/audio/types.ts`:
```typescript
// æ’­æ”¾å™¨çŠ¶æ€ç±»å‹
export type PlaybackState = 'idle' | 'loading' | 'playing' | 'paused' | 'ended' | 'error';

// éŸ³é¢‘äº‹ä»¶ç±»å‹
export type AudioEvent = 
  | 'loadstart' | 'loadeddata' | 'canplay' | 'canplaythrough'
  | 'play' | 'pause' | 'ended' | 'timeupdate' | 'progress'
  | 'volumechange' | 'error' | 'stalled';

// éŸ³é¢‘å¼•æ“æ¥å£
export interface AudioEngine {
  // æ’­æ”¾æ§åˆ¶
  play(): Promise<void>;
  pause(): void;
  stop(): void;
  seek(position: number): void;
  
  // éŸ³é‡å’ŒéŸ³æ•ˆ
  setVolume(volume: number): void;
  setMuted(muted: boolean): void;
  setPlaybackRate(rate: number): void;
  
  // éŸ³é¢‘ä¿¡æ¯
  getCurrentTime(): number;
  getDuration(): number;
  getBuffered(): TimeRanges;
  
  // çŠ¶æ€æŸ¥è¯¢
  getState(): PlaybackState;
  
  // äº‹ä»¶ç›‘å¬
  addEventListener(event: AudioEvent, handler: Function): void;
  removeEventListener(event: AudioEvent, handler: Function): void;
  
  // èµ„æºç®¡ç†
  loadSong(song: Song): Promise<void>;
  unload(): void;
  
  // éŸ³é¢‘åˆ†æ
  getFrequencyData(): Uint8Array;
}
```

#### æ­¥éª¤2.1.2: å®ç°Web AudioéŸ³é¢‘å¼•æ“
åˆ›å»º `src/services/audio/WebAudioEngine.ts`:
```typescript
import { AudioEngine, PlaybackState, AudioEvent } from './types';
import { Song } from '../../types';

export class WebAudioEngine implements AudioEngine {
  private audio: HTMLAudioElement;
  private audioContext: AudioContext | null = null;
  private gainNode: GainNode | null = null;
  private analyser: AnalyserNode | null = null;
  private source: MediaElementAudioSourceNode | null = null;
  
  private state: PlaybackState = 'idle';
  private eventListeners = new Map<AudioEvent, Set<Function>>();
  private currentSong: Song | null = null;
  
  constructor() {
    this.audio = new Audio();
    this.setupAudioElement();
    this.initializeAudioContext();
  }
  
  private setupAudioElement(): void {
    this.audio.crossOrigin = 'anonymous';
    this.audio.preload = 'metadata';
    
    // ç»‘å®šéŸ³é¢‘äº‹ä»¶
    this.audio.addEventListener('loadstart', () => this.emitEvent('loadstart'));
    this.audio.addEventListener('loadeddata', () => this.emitEvent('loadeddata'));
    this.audio.addEventListener('canplay', () => this.emitEvent('canplay'));
    this.audio.addEventListener('canplaythrough', () => this.emitEvent('canplaythrough'));
    this.audio.addEventListener('play', () => {
      this.state = 'playing';
      this.emitEvent('play');
    });
    this.audio.addEventListener('pause', () => {
      this.state = 'paused';
      this.emitEvent('pause');
    });
    this.audio.addEventListener('ended', () => {
      this.state = 'ended';
      this.emitEvent('ended');
    });
    this.audio.addEventListener('timeupdate', () => this.emitEvent('timeupdate'));
    this.audio.addEventListener('progress', () => this.emitEvent('progress'));
    this.audio.addEventListener('volumechange', () => this.emitEvent('volumechange'));
    this.audio.addEventListener('error', () => {
      this.state = 'error';
      this.emitEvent('error');
    });
    this.audio.addEventListener('stalled', () => this.emitEvent('stalled'));
  }
  
  private async initializeAudioContext(): Promise<void> {
    try {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      this.gainNode = this.audioContext.createGain();
      this.analyser = this.audioContext.createAnalyser();
      
      // é…ç½®åˆ†æå™¨
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      
      // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
      this.connectAudioNodes();
    } catch (error) {
      console.error('Failed to initialize audio context:', error);
    }
  }
  
  private connectAudioNodes(): void {
    if (!this.audioContext || !this.gainNode || !this.analyser) return;
    
    // å¦‚æœå·²æœ‰sourceï¼Œå…ˆæ–­å¼€
    if (this.source) {
      this.source.disconnect();
    }
    
    try {
      this.source = this.audioContext.createMediaElementSource(this.audio);
      this.source.connect(this.gainNode);
      this.gainNode.connect(this.analyser);
      this.analyser.connect(this.audioContext.destination);
    } catch (error) {
      console.error('Failed to connect audio nodes:', error);
    }
  }
  
  private emitEvent(event: AudioEvent): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach(listener => listener());
    }
  }
  
  // å…¬å…±æ–¹æ³•å®ç°
  async loadSong(song: Song): Promise<void> {
    this.currentSong = song;
    this.state = 'loading';
    
    if (!song.audioUrl) {
      throw new Error('Song audio URL is required');
    }
    
    return new Promise((resolve, reject) => {
      const handleCanPlay = () => {
        this.audio.removeEventListener('canplay', handleCanPlay);
        this.audio.removeEventListener('error', handleError);
        this.state = 'idle';
        resolve();
      };
      
      const handleError = () => {
        this.audio.removeEventListener('canplay', handleCanPlay);
        this.audio.removeEventListener('error', handleError);
        this.state = 'error';
        reject(new Error('Failed to load audio'));
      };
      
      this.audio.addEventListener('canplay', handleCanPlay);
      this.audio.addEventListener('error', handleError);
      
      this.audio.src = song.audioUrl;
      this.audio.load();
    });
  }
  
  async play(): Promise<void> {
    if (!this.audioContext) {
      await this.initializeAudioContext();
    }
    
    // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ (ç”¨æˆ·äº¤äº’å)
    if (this.audioContext?.state === 'suspended') {
      await this.audioContext.resume();
    }
    
    try {
      await this.audio.play();
    } catch (error) {
      console.error('Failed to play audio:', error);
      throw error;
    }
  }
  
  pause(): void {
    this.audio.pause();
  }
  
  stop(): void {
    this.audio.pause();
    this.audio.currentTime = 0;
    this.state = 'idle';
  }
  
  seek(position: number): void {
    if (this.audio.duration && position >= 0 && position <= this.audio.duration) {
      this.audio.currentTime = position;
    }
  }
  
  setVolume(volume: number): void {
    const clampedVolume = Math.max(0, Math.min(1, volume));
    this.audio.volume = clampedVolume;
    
    if (this.gainNode) {
      this.gainNode.gain.value = clampedVolume;
    }
  }
  
  setMuted(muted: boolean): void {
    this.audio.muted = muted;
  }
  
  setPlaybackRate(rate: number): void {
    this.audio.playbackRate = Math.max(0.25, Math.min(2, rate));
  }
  
  getCurrentTime(): number {
    return this.audio.currentTime || 0;
  }
  
  getDuration(): number {
    return this.audio.duration || 0;
  }
  
  getBuffered(): TimeRanges {
    return this.audio.buffered;
  }
  
  getState(): PlaybackState {
    return this.state;
  }
  
  addEventListener(event: AudioEvent, handler: Function): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, new Set());
    }
    this.eventListeners.get(event)!.add(handler);
  }
  
  removeEventListener(event: AudioEvent, handler: Function): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.delete(handler);
    }
  }
  
  getFrequencyData(): Uint8Array {
    if (!this.analyser) return new Uint8Array(0);
    
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);
    return dataArray;
  }
  
  unload(): void {
    this.stop();
    this.audio.src = '';
    this.currentSong = null;
    this.state = 'idle';
  }
  
  // æ¸…ç†èµ„æº
  dispose(): void {
    this.unload();
    
    if (this.source) {
      this.source.disconnect();
    }
    
    if (this.audioContext) {
      this.audioContext.close();
    }
    
    this.eventListeners.clear();
  }
}
```

### 2.2 æ’­æ”¾é˜Ÿåˆ—ç®¡ç†ç³»ç»Ÿ

#### æ­¥éª¤2.2.1: åˆ›å»ºæ’­æ”¾é˜Ÿåˆ—æ¥å£
åˆ›å»º `src/services/audio/PlayQueue.ts`:
```typescript
import { Song, PlayMode } from '../../types';

// æ’­æ”¾é˜Ÿåˆ—æ¥å£
export interface PlayQueue {
  // é˜Ÿåˆ—æ“ä½œ
  addSong(song: Song, index?: number): void;
  removeSong(index: number): void;
  clearQueue(): void;
  moveSong(fromIndex: number, toIndex: number): void;
  
  // æ’­æ”¾æ§åˆ¶
  next(): Song | null;
  previous(): Song | null;
  jumpTo(index: number): Song | null;
  
  // æ¨¡å¼æ§åˆ¶
  setPlayMode(mode: PlayMode): void;
  shuffle(): void;
  
  // çŠ¶æ€æŸ¥è¯¢
  getCurrentSong(): Song | null;
  getCurrentIndex(): number;
  getQueue(): Song[];
  getQueueLength(): number;
  
  // äº‹ä»¶ç›‘å¬
  onQueueChange(callback: (queue: Song[]) => void): void;
  onCurrentChange(callback: (song: Song | null, index: number) => void): void;
}

export class MusicPlayQueue implements PlayQueue {
  private queue: Song[] = [];
  private currentIndex: number = -1;
  private playMode: PlayMode = PlayMode.SEQUENCE;
  private shuffleIndices: number[] = [];
  private originalQueue: Song[] = [];
  private playHistory: number[] = [];
  
  // äº‹ä»¶å›è°ƒ
  private queueChangeCallbacks = new Set<(queue: Song[]) => void>();
  private currentChangeCallbacks = new Set<(song: Song | null, index: number) => void>();
  
  constructor() {
    this.generateShuffleIndices();
  }
  
  private generateShuffleIndices(): void {
    this.shuffleIndices = Array.from(
      { length: this.queue.length }, 
      (_, i) => i
    ).sort(() => Math.random() - 0.5);
  }
  
  private emitQueueChange(): void {
    this.queueChangeCallbacks.forEach(callback => callback(this.queue));
  }
  
  private emitCurrentChange(): void {
    const currentSong = this.getCurrentSong();
    this.currentChangeCallbacks.forEach(callback => 
      callback(currentSong, this.currentIndex)
    );
  }
  
  // é˜Ÿåˆ—æ“ä½œ
  addSong(song: Song, index?: number): void {
    if (index !== undefined && index >= 0 && index <= this.queue.length) {
      this.queue.splice(index, 0, song);
      if (index <= this.currentIndex) {
        this.currentIndex++;
      }
    } else {
      this.queue.push(song);
    }
    
    this.generateShuffleIndices();
    this.emitQueueChange();
  }
  
  removeSong(index: number): void {
    if (index >= 0 && index < this.queue.length) {
      this.queue.splice(index, 1);
      
      if (index < this.currentIndex) {
        this.currentIndex--;
      } else if (index === this.currentIndex) {
        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ­Œæ›²ï¼Œé‡æ–°è®¾å®šå½“å‰ä½ç½®
        if (this.currentIndex >= this.queue.length) {
          this.currentIndex = this.queue.length - 1;
        }
        this.emitCurrentChange();
      }
      
      this.generateShuffleIndices();
      this.emitQueueChange();
    }
  }
  
  clearQueue(): void {
    this.queue = [];
    this.currentIndex = -1;
    this.shuffleIndices = [];
    this.playHistory = [];
    this.emitQueueChange();
    this.emitCurrentChange();
  }
  
  moveSong(fromIndex: number, toIndex: number): void {
    if (fromIndex >= 0 && fromIndex < this.queue.length &&
        toIndex >= 0 && toIndex < this.queue.length &&
        fromIndex !== toIndex) {
      
      const song = this.queue.splice(fromIndex, 1)[0];
      this.queue.splice(toIndex, 0, song);
      
      // æ›´æ–°å½“å‰ç´¢å¼•
      if (fromIndex === this.currentIndex) {
        this.currentIndex = toIndex;
      } else if (fromIndex < this.currentIndex && toIndex >= this.currentIndex) {
        this.currentIndex--;
      } else if (fromIndex > this.currentIndex && toIndex <= this.currentIndex) {
        this.currentIndex++;
      }
      
      this.generateShuffleIndices();
      this.emitQueueChange();
      this.emitCurrentChange();
    }
  }
  
  // æ’­æ”¾æ§åˆ¶
  next(): Song | null {
    switch (this.playMode) {
      case PlayMode.SEQUENCE:
        return this.getNextSequential();
      case PlayMode.RANDOM:
        return this.getNextRandom();
      case PlayMode.SINGLE:
        return this.getCurrentSong();
      case PlayMode.LIST_LOOP:
        return this.getNextLoop();
      default:
        return null;
    }
  }
  
  private getNextSequential(): Song | null {
    if (this.currentIndex < this.queue.length - 1) {
      this.currentIndex++;
      this.emitCurrentChange();
      return this.queue[this.currentIndex];
    }
    return null;
  }
  
  private getNextRandom(): Song | null {
    if (this.queue.length === 0) return null;
    
    // é¿å…é‡å¤æ’­æ”¾æœ€è¿‘çš„æ­Œæ›²
    const maxHistorySize = Math.min(5, Math.floor(this.queue.length / 2));
    let attempts = 0;
    let nextIndex;
    
    do {
      nextIndex = Math.floor(Math.random() * this.queue.length);
      attempts++;
    } while (
      this.playHistory.includes(nextIndex) && 
      attempts < 10 && 
      this.playHistory.length < this.queue.length
    );
    
    this.currentIndex = nextIndex;
    
    // æ›´æ–°æ’­æ”¾å†å²
    this.playHistory.push(nextIndex);
    if (this.playHistory.length > maxHistorySize) {
      this.playHistory.shift();
    }
    
    this.emitCurrentChange();
    return this.queue[this.currentIndex];
  }
  
  private getNextLoop(): Song | null {
    if (this.queue.length === 0) return null;
    
    this.currentIndex = (this.currentIndex + 1) % this.queue.length;
    this.emitCurrentChange();
    return this.queue[this.currentIndex];
  }
  
  previous(): Song | null {
    switch (this.playMode) {
      case PlayMode.SEQUENCE:
      case PlayMode.LIST_LOOP:
        return this.getPreviousSequential();
      case PlayMode.RANDOM:
        return this.getPreviousRandom();
      case PlayMode.SINGLE:
        return this.getCurrentSong();
      default:
        return null;
    }
  }
  
  private getPreviousSequential(): Song | null {
    if (this.playMode === PlayMode.LIST_LOOP && this.currentIndex === 0) {
      this.currentIndex = this.queue.length - 1;
    } else if (this.currentIndex > 0) {
      this.currentIndex--;
    } else {
      return null;
    }
    
    this.emitCurrentChange();
    return this.queue[this.currentIndex];
  }
  
  private getPreviousRandom(): Song | null {
    if (this.playHistory.length > 1) {
      this.playHistory.pop(); // ç§»é™¤å½“å‰
      const previousIndex = this.playHistory.pop(); // è·å–ä¸Šä¸€é¦–
      if (previousIndex !== undefined) {
        this.currentIndex = previousIndex;
        this.emitCurrentChange();
        return this.queue[this.currentIndex];
      }
    }
    
    // å¦‚æœæ²¡æœ‰å†å²ï¼Œéšæœºé€‰æ‹©
    return this.getNextRandom();
  }
  
  jumpTo(index: number): Song | null {
    if (index >= 0 && index < this.queue.length) {
      this.currentIndex = index;
      this.emitCurrentChange();
      return this.queue[this.currentIndex];
    }
    return null;
  }
  
  // æ¨¡å¼æ§åˆ¶
  setPlayMode(mode: PlayMode): void {
    this.playMode = mode;
    
    if (mode === PlayMode.RANDOM) {
      this.generateShuffleIndices();
      this.playHistory = [];
    }
  }
  
  shuffle(): void {
    if (this.queue.length <= 1) return;
    
    const currentSong = this.getCurrentSong();
    
    // Fisher-Yates æ´—ç‰Œç®—æ³•
    for (let i = this.queue.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.queue[i], this.queue[j]] = [this.queue[j], this.queue[i]];
    }
    
    // ä¿æŒå½“å‰æ­Œæ›²ä½ç½®
    if (currentSong) {
      const newIndex = this.queue.findIndex(song => song.id === currentSong.id);
      if (newIndex !== -1) {
        this.currentIndex = newIndex;
      }
    }
    
    this.generateShuffleIndices();
    this.emitQueueChange();
    this.emitCurrentChange();
  }
  
  // çŠ¶æ€æŸ¥è¯¢
  getCurrentSong(): Song | null {
    return this.currentIndex >= 0 && this.currentIndex < this.queue.length 
      ? this.queue[this.currentIndex] 
      : null;
  }
  
  getCurrentIndex(): number {
    return this.currentIndex;
  }
  
  getQueue(): Song[] {
    return [...this.queue];
  }
  
  getQueueLength(): number {
    return this.queue.length;
  }
  
  // äº‹ä»¶ç›‘å¬
  onQueueChange(callback: (queue: Song[]) => void): void {
    this.queueChangeCallbacks.add(callback);
  }
  
  onCurrentChange(callback: (song: Song | null, index: number) => void): void {
    this.currentChangeCallbacks.add(callback);
  }
  
  // ç§»é™¤äº‹ä»¶ç›‘å¬
  offQueueChange(callback: (queue: Song[]) => void): void {
    this.queueChangeCallbacks.delete(callback);
  }
  
  offCurrentChange(callback: (song: Song | null, index: number) => void): void {
    this.currentChangeCallbacks.delete(callback);
  }
}
```

### 2.3 éŸ³é¢‘æœåŠ¡é›†æˆ

#### æ­¥éª¤2.3.1: åˆ›å»ºç»Ÿä¸€éŸ³é¢‘æœåŠ¡
åˆ›å»º `src/services/audio/AudioService.ts`:
```typescript
import { WebAudioEngine } from './WebAudioEngine';
import { MusicPlayQueue } from './PlayQueue';
import { Song, PlayMode } from '../../types';
import { AudioEngine, PlaybackState } from './types';

export class AudioService {
  private audioEngine: AudioEngine;
  private playQueue: MusicPlayQueue;
  private isInitialized = false;
  
  constructor() {
    this.audioEngine = new WebAudioEngine();
    this.playQueue = new MusicPlayQueue();
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    // ç›‘å¬æ’­æ”¾ç»“æŸäº‹ä»¶ï¼Œè‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€é¦–
    this.audioEngine.addEventListener('ended', () => {
      this.playNext();
    });
    
    // ç›‘å¬æ’­æ”¾é”™è¯¯ï¼Œå°è¯•æ’­æ”¾ä¸‹ä¸€é¦–
    this.audioEngine.addEventListener('error', () => {
      console.error('Audio playback error, trying next song');
      setTimeout(() => this.playNext(), 1000);
    });
  }
  
  async initialize(): Promise<void> {
    if (this.isInitialized) return;
    
    try {
      // åˆå§‹åŒ–éŸ³é¢‘å¼•æ“
      this.isInitialized = true;
    } catch (error) {
      console.error('Failed to initialize audio service:', error);
      throw error;
    }
  }
  
  // æ’­æ”¾æ§åˆ¶
  async play(song?: Song): Promise<void> {
    await this.initialize();
    
    if (song) {
      // æ’­æ”¾æŒ‡å®šæ­Œæ›²
      await this.loadAndPlay(song);
    } else {
      // ç»§ç»­æ’­æ”¾å½“å‰æ­Œæ›²
      await this.audioEngine.play();
    }
  }
  
  private async loadAndPlay(song: Song): Promise<void> {
    try {
      await this.audioEngine.loadSong(song);
      await this.audioEngine.play();
    } catch (error) {
      console.error('Failed to load and play song:', error);
      throw error;
    }
  }
  
  pause(): void {
    this.audioEngine.pause();
  }
  
  stop(): void {
    this.audioEngine.stop();
  }
  
  async playNext(): Promise<void> {
    const nextSong = this.playQueue.next();
    if (nextSong) {
      await this.play(nextSong);
    }
  }
  
  async playPrevious(): Promise<void> {
    const previousSong = this.playQueue.previous();
    if (previousSong) {
      await this.play(previousSong);
    }
  }
  
  async jumpToSong(index: number): Promise<void> {
    const song = this.playQueue.jumpTo(index);
    if (song) {
      await this.play(song);
    }
  }
  
  // éŸ³é¢‘æ§åˆ¶
  seek(position: number): void {
    this.audioEngine.seek(position);
  }
  
  setVolume(volume: number): void {
    this.audioEngine.setVolume(volume);
  }
  
  setMuted(muted: boolean): void {
    this.audioEngine.setMuted(muted);
  }
  
  // æ’­æ”¾æ¨¡å¼
  setPlayMode(mode: PlayMode): void {
    this.playQueue.setPlayMode(mode);
  }
  
  shuffleQueue(): void {
    this.playQueue.shuffle();
  }
  
  // é˜Ÿåˆ—ç®¡ç†
  addToQueue(song: Song, index?: number): void {
    this.playQueue.addSong(song, index);
  }
  
  removeFromQueue(index: number): void {
    this.playQueue.removeSong(index);
  }
  
  clearQueue(): void {
    this.playQueue.clearQueue();
    this.stop();
  }
  
  setQueue(songs: Song[], startIndex = 0): void {
    this.clearQueue();
    songs.forEach(song => this.addToQueue(song));
    if (songs.length > 0 && startIndex >= 0 && startIndex < songs.length) {
      this.playQueue.jumpTo(startIndex);
    }
  }
  
  // çŠ¶æ€æŸ¥è¯¢
  getCurrentSong(): Song | null {
    return this.playQueue.getCurrentSong();
  }
  
  getQueue(): Song[] {
    return this.playQueue.getQueue();
  }
  
  getCurrentTime(): number {
    return this.audioEngine.getCurrentTime();
  }
  
  getDuration(): number {
    return this.audioEngine.getDuration();
  }
  
  getState(): PlaybackState {
    return this.audioEngine.getState();
  }
  
  getFrequencyData(): Uint8Array {
    return this.audioEngine.getFrequencyData();
  }
  
  // äº‹ä»¶ç›‘å¬
  addEventListener(event: string, handler: Function): void {
    if (event.startsWith('queue_')) {
      // é˜Ÿåˆ—äº‹ä»¶
      const queueEvent = event.replace('queue_', '');
      if (queueEvent === 'change') {
        this.playQueue.onQueueChange(handler as any);
      } else if (queueEvent === 'current_change') {
        this.playQueue.onCurrentChange(handler as any);
      }
    } else {
      // éŸ³é¢‘äº‹ä»¶
      this.audioEngine.addEventListener(event as any, handler);
    }
  }
  
  removeEventListener(event: string, handler: Function): void {
    if (event.startsWith('queue_')) {
      // é˜Ÿåˆ—äº‹ä»¶ç§»é™¤
      const queueEvent = event.replace('queue_', '');
      if (queueEvent === 'change') {
        this.playQueue.offQueueChange(handler as any);
      } else if (queueEvent === 'current_change') {
        this.playQueue.offCurrentChange(handler as any);
      }
    } else {
      // éŸ³é¢‘äº‹ä»¶
      this.audioEngine.removeEventListener(event as any, handler);
    }
  }
  
  // æ¸…ç†èµ„æº
  dispose(): void {
    this.clearQueue();
    
    if (this.audioEngine && 'dispose' in this.audioEngine) {
      (this.audioEngine as any).dispose();
    }
  }
}

// å•ä¾‹æ¨¡å¼
export const audioService = new AudioService();
```

### 2.4 éªŒæ”¶æ ‡å‡†

#### é˜¶æ®µ2å®Œæˆæ£€æŸ¥æ¸…å•ï¼š
- [ ] âœ… éŸ³é¢‘å¼•æ“å¯ä»¥æ­£å¸¸æ’­æ”¾ã€æš‚åœã€åœæ­¢
- [ ] âœ… æ’­æ”¾é˜Ÿåˆ—ç®¡ç†åŠŸèƒ½å®Œæ•´ï¼ˆæ·»åŠ ã€åˆ é™¤ã€ç§»åŠ¨ï¼‰
- [ ] âœ… æ’­æ”¾æ¨¡å¼åˆ‡æ¢æ­£å¸¸ï¼ˆé¡ºåºã€éšæœºã€å•æ›²ã€å¾ªç¯ï¼‰
- [ ] âœ… éŸ³é‡æ§åˆ¶å’Œè¿›åº¦æ§åˆ¶æ­£å¸¸
- [ ] âœ… äº‹ä»¶ç›‘å¬æœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] âœ… éŸ³é¢‘å¯è§†åŒ–æ•°æ®è·å–æ­£å¸¸
- [ ] âœ… ç»Ÿä¸€éŸ³é¢‘æœåŠ¡æ¥å£å®Œæ•´

**æµ‹è¯•æ–¹æ³•ï¼š**
```typescript
// åˆ›å»ºæµ‹è¯•æ–‡ä»¶ src/services/audio/__tests__/AudioService.test.ts
import { audioService } from '../AudioService';
import { Song, MusicSource, AudioQuality } from '../../../types';

const testSong: Song = {
  id: 'test-1',
  title: 'Test Song',
  artist: 'Test Artist',
  album: 'Test Album',
  duration: 180,
  coverUrl: 'https://example.com/cover.jpg',
  audioUrl: 'https://example.com/audio.mp3',
  source: MusicSource.LOCAL,
  quality: AudioQuality.STANDARD
};

describe('AudioService', () => {
  beforeEach(() => {
    audioService.clearQueue();
  });
  
  test('should add song to queue', () => {
    audioService.addToQueue(testSong);
    expect(audioService.getQueue()).toHaveLength(1);
    expect(audioService.getQueue()[0]).toBe(testSong);
  });
  
  test('should play song', async () => {
    audioService.addToQueue(testSong);
    await audioService.play(testSong);
    expect(audioService.getCurrentSong()).toBe(testSong);
  });
  
  // æ›´å¤šæµ‹è¯•ç”¨ä¾‹...
});
```

---

## ğŸ¨ é˜¶æ®µ3: UIç»„ä»¶å¼€å‘ (ç¬¬5-7å‘¨)

### 3.1 åŸºç¡€ç»„ä»¶åº“æ­å»º

#### æ­¥éª¤3.1.1: åˆ›å»ºåŸºç¡€UIç»„ä»¶
åˆ›å»º `src/components/common/Button.tsx`:
```typescript
import React from 'react';
import { cn } from '../../utils';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'primary' | 'secondary' | 'ghost' | 'destructive';
  size?: 'sm' | 'md' | 'lg' | 'xl';
  loading?: boolean;
  icon?: React.ReactNode;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ 
    className, 
    variant = 'default', 
    size = 'md', 
    loading = false,
    icon,
    children, 
    disabled,
    ...props 
  }, ref) => {
    const baseClasses = 'inline-flex items-center justify-center rounded-lg font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none';
    
    const variants = {
      default: 'bg-white text-gray-900 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500',
      primary: 'bg-netease text-white hover:bg-red-600 focus:ring-red-500',
      secondary: 'bg-gray-100 text-gray-900 hover:bg-gray-200 focus:ring-gray-500',
      ghost: 'text-gray-600 hover:text-gray-900 hover:bg-gray-100 focus:ring-gray-500',
      destructive: 'bg-red-500 text-white hover:bg-red-600 focus:ring-red-500',
    };
    
    const sizes = {
      sm: 'h-8 px-3 text-sm',
      md: 'h-10 px-4 text-sm',
      lg: 'h-12 px-6 text-base',
      xl: 'h-14 px-8 text-lg',
    };
    
    return (
      <button
        className={cn(
          baseClasses,
          variants[variant],
          sizes[size],
          className
        )}
        ref={ref}
        disabled={disabled || loading}
        {...props}
      >
        {loading && (
          <svg className="animate-spin -ml-1 mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        )}
        {icon && !loading && <span className="mr-2">{icon}</span>}
        {children}
      </button>
    );
  }
);

Button.displayName = 'Button';
```

#### æ­¥éª¤3.1.2: åˆ›å»ºæ»‘å—ç»„ä»¶
åˆ›å»º `src/components/common/Slider.tsx`:
```typescript
import React, { useState, useCallback, useRef, useEffect } from 'react';
import { cn } from '../../utils';

interface SliderProps {
  value: number;
  max: number;
  min?: number;
  step?: number;
  onChange: (value: number) => void;
  onDragStart?: () => void;
  onDragEnd?: () => void;
  className?: string;
  disabled?: boolean;
  showTooltip?: boolean;
  formatTooltip?: (value: number) => string;
}

export const Slider: React.FC<SliderProps> = ({
  value,
  max,
  min = 0,
  step = 1,
  onChange,
  onDragStart,
  onDragEnd,
  className,
  disabled = false,
  showTooltip = false,
  formatTooltip = (val) => val.toString(),
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [dragValue, setDragValue] = useState(value);
  const sliderRef = useRef<HTMLDivElement>(null);
  
  const percentage = max > min ? ((isDragging ? dragValue : value) - min) / (max - min) * 100 : 0;
  
  const updateValue = useCallback((clientX: number) => {
    if (!sliderRef.current || disabled) return;
    
    const rect = sliderRef.current.getBoundingClientRect();
    const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    const newValue = min + percent * (max - min);
    const steppedValue = Math.round(newValue / step) * step;
    const clampedValue = Math.max(min, Math.min(max, steppedValue));
    
    if (isDragging) {
      setDragValue(clampedValue);
    } else {
      onChange(clampedValue);
    }
  }, [min, max, step, isDragging, disabled, onChange]);
  
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (disabled) return;
    
    setIsDragging(true);
    onDragStart?.();
    updateValue(e.clientX);
    
    const handleMouseMove = (e: MouseEvent) => {
      updateValue(e.clientX);
    };
    
    const handleMouseUp = () => {
      setIsDragging(false);
      onChange(dragValue);
      onDragEnd?.();
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [disabled, dragValue, onChange, onDragStart, onDragEnd, updateValue]);
  
  const handleTrackClick = useCallback((e: React.MouseEvent) => {
    if (disabled || isDragging) return;
    updateValue(e.clientX);
  }, [disabled, isDragging, updateValue]);
  
  return (
    <div className={cn('relative w-full', className)}>
      <div
        ref={sliderRef}
        className={cn(
          'relative h-2 bg-gray-200 rounded-full cursor-pointer',
          disabled && 'cursor-not-allowed opacity-50'
        )}
        onMouseDown={handleTrackClick}
      >
        {/* è¿›åº¦æ¡ */}
        <div
          className="absolute h-full bg-netease rounded-full"
          style={{ width: `${percentage}%` }}
        />
        
        {/* æ»‘å— */}
        <div
          className={cn(
            'absolute w-4 h-4 bg-white border-2 border-netease rounded-full shadow-sm transform -translate-x-1/2 -translate-y-1/2 top-1/2 cursor-grab',
            isDragging && 'cursor-grabbing scale-110',
            disabled && 'cursor-not-allowed'
          )}
          style={{ left: `${percentage}%` }}
          onMouseDown={handleMouseDown}
        />
        
        {/* æç¤ºæ¡† */}
        {showTooltip && isDragging && (
          <div
            className="absolute bottom-6 transform -translate-x-1/2 px-2 py-1 bg-gray-900 text-white text-xs rounded whitespace-nowrap"
            style={{ left: `${percentage}%` }}
          >
            {formatTooltip(isDragging ? dragValue : value)}
          </div>
        )}
      </div>
    </div>
  );
};
```

### 3.2 æ’­æ”¾å™¨æ§åˆ¶ç»„ä»¶

#### æ­¥éª¤3.2.1: åˆ›å»ºæ’­æ”¾æ§åˆ¶æŒ‰é’®ç»„
åˆ›å»º `src/components/player/PlayControls.tsx`:
```typescript
import React from 'react';
import { Play, Pause, SkipBack, SkipForward, Shuffle, Repeat, Repeat1 } from 'lucide-react';
import { Button } from '../common/Button';
import { PlayMode } from '../../types';
import { cn } from '../../utils';

interface PlayControlsProps {
  isPlaying: boolean;
  playMode: PlayMode;
  onPlay: () => void;
  onPause: () => void;
  onNext: () => void;
  onPrevious: () => void;
  onShuffle: () => void;
  onPlayModeChange: (mode: PlayMode) => void;
  disabled?: boolean;
  className?: string;
}

export const PlayControls: React.FC<PlayControlsProps> = ({
  isPlaying,
  playMode,
  onPlay,
  onPause,
  onNext,
  onPrevious,
  onShuffle,
  onPlayModeChange,
  disabled = false,
  className,
}) => {
  const handlePlayModeClick = () => {
    const modes = [PlayMode.SEQUENCE, PlayMode.LIST_LOOP, PlayMode.SINGLE];
    const currentIndex = modes.indexOf(playMode);
    const nextIndex = (currentIndex + 1) % modes.length;
    onPlayModeChange(modes[nextIndex]);
  };
  
  const getPlayModeIcon = () => {
    switch (playMode) {
      case PlayMode.SINGLE:
        return <Repeat1 className="w-4 h-4" />;
      case PlayMode.LIST_LOOP:
        return <Repeat className="w-4 h-4" />;
      case PlayMode.RANDOM:
        return <Shuffle className="w-4 h-4 text-netease" />;
      default:
        return <Repeat className="w-4 h-4" />;
    }
  };
  
  const getPlayModeTooltip = () => {
    switch (playMode) {
      case PlayMode.SEQUENCE:
        return 'é¡ºåºæ’­æ”¾';
      case PlayMode.LIST_LOOP:
        return 'åˆ—è¡¨å¾ªç¯';
      case PlayMode.SINGLE:
        return 'å•æ›²å¾ªç¯';
      case PlayMode.RANDOM:
        return 'éšæœºæ’­æ”¾';
      default:
        return 'æ’­æ”¾æ¨¡å¼';
    }
  };
  
  return (
    <div className={cn('flex items-center space-x-2', className)}>
      {/* æ’­æ”¾æ¨¡å¼ */}
      <Button
        variant="ghost"
        size="sm"
        onClick={handlePlayModeClick}
        disabled={disabled}
        title={getPlayModeTooltip()}
        className="text-gray-600 hover:text-gray-900"
      >
        {getPlayModeIcon()}
      </Button>
      
      {/* ä¸Šä¸€é¦– */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onPrevious}
        disabled={disabled}
        title="ä¸Šä¸€é¦–"
        className="text-gray-600 hover:text-gray-900"
      >
        <SkipBack className="w-5 h-5" />
      </Button>
      
      {/* æ’­æ”¾/æš‚åœ */}
      <Button
        variant="primary"
        size="lg"
        onClick={isPlaying ? onPause : onPlay}
        disabled={disabled}
        title={isPlaying ? 'æš‚åœ' : 'æ’­æ”¾'}
        className="bg-netease hover:bg-red-600 text-white rounded-full w-12 h-12"
      >
        {isPlaying ? (
          <Pause className="w-6 h-6" />
        ) : (
          <Play className="w-6 h-6 ml-0.5" />
        )}
      </Button>
      
      {/* ä¸‹ä¸€é¦– */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onNext}
        disabled={disabled}
        title="ä¸‹ä¸€é¦–"
        className="text-gray-600 hover:text-gray-900"
      >
        <SkipForward className="w-5 h-5" />
      </Button>
      
      {/* éšæœºæ’­æ”¾ */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onShuffle}
        disabled={disabled}
        title="éšæœºæ’­æ”¾"
        className={cn(
          'text-gray-600 hover:text-gray-900',
          playMode === PlayMode.RANDOM && 'text-netease'
        )}
      >
        <Shuffle className="w-4 h-4" />
      </Button>
    </div>
  );
};
```

#### æ­¥éª¤3.2.2: åˆ›å»ºè¿›åº¦æ¡ç»„ä»¶
åˆ›å»º `src/components/player/ProgressBar.tsx`:
```typescript
import React, { useState, useCallback } from 'react';
import { Slider } from '../common/Slider';
import { formatTime, cn } from '../../utils';

interface ProgressBarProps {
  currentTime: number;
  duration: number;
  buffered?: number;
  onSeek: (time: number) => void;
  onSeekStart?: () => void;
  onSeekEnd?: () => void;
  className?: string;
  disabled?: boolean;
}

export const ProgressBar: React.FC<ProgressBarProps> = ({
  currentTime,
  duration,
  buffered = 0,
  onSeek,
  onSeekStart,
  onSeekEnd,
  className,
  disabled = false,
}) => {
  const [isPreview, setIsPreview] = useState(false);
  const [previewTime, setPreviewTime] = useState(0);
  
  const bufferedPercent = duration ? (buffered / duration) * 100 : 0;
  
  const handleSeekStart = useCallback(() => {
    setIsPreview(true);
    onSeekStart?.();
  }, [onSeekStart]);
  
  const handleSeekEnd = useCallback(() => {
    setIsPreview(false);
    onSeekEnd?.();
  }, [onSeekEnd]);
  
  const handleSeek = useCallback((value: number) => {
    if (isPreview) {
      setPreviewTime(value);
    } else {
      onSeek(value);
    }
  }, [isPreview, onSeek]);
  
  const displayTime = isPreview ? previewTime : currentTime;
  
  return (
    <div className={cn('w-full px-3', className)}>
      <div className="flex items-center space-x-3 text-xs text-gray-500">
        {/* å½“å‰æ—¶é—´ */}
        <span className="w-10 text-right">
          {formatTime(displayTime)}
        </span>
        
        {/* è¿›åº¦æ¡å®¹å™¨ */}
        <div className="flex-1 relative">
          {/* ç¼“å†²è¿›åº¦èƒŒæ™¯ */}
          <div className="absolute inset-0 h-1 bg-gray-200 rounded-full">
            <div
              className="h-full bg-gray-300 rounded-full transition-all duration-300"
              style={{ width: `${bufferedPercent}%` }}
            />
          </div>
          
          {/* ä¸»è¿›åº¦æ¡ */}
          <Slider
            value={displayTime}
            max={duration || 100}
            min={0}
            step={0.1}
            onChange={handleSeek}
            onDragStart={handleSeekStart}
            onDragEnd={handleSeekEnd}
            disabled={disabled || !duration}
            showTooltip={isPreview}
            formatTooltip={formatTime}
            className="relative z-10"
          />
        </div>
        
        {/* æ€»æ—¶é•¿ */}
        <span className="w-10">
          {formatTime(duration)}
        </span>
      </div>
    </div>
  );
};
```

#### æ­¥éª¤3.2.3: åˆ›å»ºéŸ³é‡æ§åˆ¶ç»„ä»¶
åˆ›å»º `src/components/player/VolumeControl.tsx`:
```typescript
import React, { useState } from 'react';
import { Volume2, VolumeX, Volume1 } from 'lucide-react';
import { Button } from '../common/Button';
import { Slider } from '../common/Slider';
import { cn } from '../../utils';

interface VolumeControlProps {
  volume: number;
  isMuted: boolean;
  onVolumeChange: (volume: number) => void;
  onMuteToggle: () => void;
  className?: string;
  showSlider?: boolean;
}

export const VolumeControl: React.FC<VolumeControlProps> = ({
  volume,
  isMuted,
  onVolumeChange,
  onMuteToggle,
  className,
  showSlider = true,
}) => {
  const [showVolumeSlider, setShowVolumeSlider] = useState(false);
  
  const getVolumeIcon = () => {
    if (isMuted || volume === 0) {
      return <VolumeX className="w-5 h-5" />;
    } else if (volume < 0.5) {
      return <Volume1 className="w-5 h-5" />;
    } else {
      return <Volume2 className="w-5 h-5" />;
    }
  };
  
  const displayVolume = isMuted ? 0 : volume;
  
  return (
    <div className={cn('flex items-center space-x-2', className)}>
      {/* éŸ³é‡æŒ‰é’® */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onMuteToggle}
        onMouseEnter={() => setShowVolumeSlider(true)}
        onMouseLeave={() => setShowVolumeSlider(false)}
        className="text-gray-600 hover:text-gray-900"
        title={isMuted ? 'å–æ¶ˆé™éŸ³' : 'é™éŸ³'}
      >
        {getVolumeIcon()}
      </Button>
      
      {/* éŸ³é‡æ»‘å— */}
      {showSlider && (
        <div
          className={cn(
            'relative',
            showVolumeSlider ? 'w-20' : 'w-0 overflow-hidden'
          )}
          onMouseEnter={() => setShowVolumeSlider(true)}
          onMouseLeave={() => setShowVolumeSlider(false)}
        >
          <Slider
            value={displayVolume}
            max={1}
            min={0}
            step={0.01}
            onChange={onVolumeChange}
            className="transition-all duration-200"
            showTooltip={true}
            formatTooltip={(val) => `${Math.round(val * 100)}%`}
          />
        </div>
      )}
    </div>
  );
};
```

### 3.3 æ­Œæ›²ä¿¡æ¯æ˜¾ç¤ºç»„ä»¶

#### æ­¥éª¤3.3.1: åˆ›å»ºæ­Œæ›²ä¿¡æ¯ç»„ä»¶
åˆ›å»º `src/components/player/SongInfo.tsx`:
```typescript
import React, { useState } from 'react';
import { Heart, MoreHorizontal } from 'lucide-react';
import { Button } from '../common/Button';
import { Song } from '../../types';
import { cn } from '../../utils';

interface SongInfoProps {
  song: Song | null;
  isFavorite?: boolean;
  onFavoriteToggle?: () => void;
  onMoreClick?: () => void;
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  showControls?: boolean;
}

export const SongInfo: React.FC<SongInfoProps> = ({
  song,
  isFavorite = false,
  onFavoriteToggle,
  onMoreClick,
  className,
  size = 'md',
  showControls = true,
}) => {
  const [imageError, setImageError] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  
  if (!song) {
    return (
      <div className={cn('flex items-center space-x-3', className)}>
        <div className={cn(
          'bg-gray-200 rounded flex items-center justify-center',
          size === 'sm' && 'w-10 h-10',
          size === 'md' && 'w-12 h-12',
          size === 'lg' && 'w-16 h-16'
        )}>
          <span className="text-gray-400 text-xs">â™ª</span>
        </div>
        <div className="flex-1 min-w-0">
          <div className={cn(
            'text-gray-400',
            size === 'sm' && 'text-sm',
            size === 'md' && 'text-base',
            size === 'lg' && 'text-lg'
          )}>
            æœªåœ¨æ’­æ”¾
          </div>
        </div>
      </div>
    );
  }
  
  return (
    <div className={cn('flex items-center space-x-3', className)}>
      {/* ä¸“è¾‘å°é¢ */}
      <div className={cn(
        'relative bg-gray-200 rounded overflow-hidden flex-shrink-0',
        size === 'sm' && 'w-10 h-10',
        size === 'md' && 'w-12 h-12',
        size === 'lg' && 'w-16 h-16'
      )}>
        {!imageError && song.coverUrl && (
          <img
            src={song.coverUrl}
            alt={song.title}
            className={cn(
              'w-full h-full object-cover transition-opacity duration-200',
              imageLoaded ? 'opacity-100' : 'opacity-0'
            )}
            onLoad={() => setImageLoaded(true)}
            onError={() => setImageError(true)}
          />
        )}
        {(imageError || !song.coverUrl || !imageLoaded) && (
          <div className="absolute inset-0 flex items-center justify-center">
            <span className="text-gray-400 text-xs">â™ª</span>
          </div>
        )}
      </div>
      
      {/* æ­Œæ›²ä¿¡æ¯ */}
      <div className="flex-1 min-w-0">
        <div className={cn(
          'font-medium text-gray-900 truncate',
          size === 'sm' && 'text-sm',
          size === 'md' && 'text-base',
          size === 'lg' && 'text-lg'
        )}>
          {song.title}
        </div>
        <div className={cn(
          'text-gray-500 truncate',
          size === 'sm' && 'text-xs',
          size === 'md' && 'text-sm',
          size === 'lg' && 'text-base'
        )}>
          {song.artist}
        </div>
        {size === 'lg' && (
          <div className="text-xs text-gray-400 truncate">
            {song.album}
          </div>
        )}
      </div>
      
      {/* æ§åˆ¶æŒ‰é’® */}
      {showControls && (
        <div className="flex items-center space-x-1">
          <Button
            variant="ghost"
            size="sm"
            onClick={onFavoriteToggle}
            className={cn(
              'text-gray-400 hover:text-gray-600',
              isFavorite && 'text-red-500 hover:text-red-600'
            )}
            title={isFavorite ? 'å–æ¶ˆæ”¶è—' : 'æ”¶è—'}
          >
            <Heart className={cn(
              'w-4 h-4',
              isFavorite && 'fill-current'
            )} />
          </Button>
          
          <Button
            variant="ghost"
            size="sm"
            onClick={onMoreClick}
            className="text-gray-400 hover:text-gray-600"
            title="æ›´å¤šé€‰é¡¹"
          >
            <MoreHorizontal className="w-4 h-4" />
          </Button>
        </div>
      )}
    </div>
  );
};
```

### 3.4 éªŒæ”¶æ ‡å‡†

#### é˜¶æ®µ3å®Œæˆæ£€æŸ¥æ¸…å•ï¼š
- [ ] âœ… åŸºç¡€UIç»„ä»¶åº“å®Œæ•´ï¼ˆButtonã€Sliderç­‰ï¼‰
- [ ] âœ… æ’­æ”¾æ§åˆ¶ç»„ä»¶åŠŸèƒ½æ­£å¸¸
- [ ] âœ… è¿›åº¦æ¡æ”¯æŒæ‹–æ‹½å’Œé¢„è§ˆ
- [ ] âœ… éŸ³é‡æ§åˆ¶äº¤äº’æµç•…
- [ ] âœ… æ­Œæ›²ä¿¡æ¯æ˜¾ç¤ºå®Œæ•´
- [ ] âœ… ç»„ä»¶å“åº”å¼è®¾è®¡æ­£å¸¸
- [ ] âœ… ç»„ä»¶å¯è®¿é—®æ€§æ”¯æŒ

**æµ‹è¯•æ–¹æ³•ï¼š**
åˆ›å»ºç»„ä»¶æµ‹è¯•é¡µé¢éªŒè¯æ‰€æœ‰äº¤äº’åŠŸèƒ½æ­£å¸¸å·¥ä½œã€‚

---

---

## ğŸ”Œ é˜¶æ®µ4: APIé›†æˆä¸æ•°æ®ç®¡ç† (ç¬¬8-9å‘¨)

### 4.1 çŠ¶æ€ç®¡ç†æ¶æ„

#### æ­¥éª¤4.1.1: åˆ›å»ºZustandçŠ¶æ€å­˜å‚¨
åˆ›å»º `src/stores/playerStore.ts`:
```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { Song, PlayMode, PlaybackState } from '../types';
import { audioService } from '../services/audio/AudioService';

interface PlayerState {
  // æ’­æ”¾å™¨çŠ¶æ€
  currentSong: Song | null;
  isPlaying: boolean;
  isPaused: boolean;
  isLoading: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  playMode: PlayMode;
  error: string | null;
  
  // æ’­æ”¾é˜Ÿåˆ—
  queue: Song[];
  currentIndex: number;
  
  // Actions
  play: (song?: Song) => Promise<void>;
  pause: () => void;
  stop: () => void;
  seek: (time: number) => void;
  next: () => Promise<void>;
  previous: () => Promise<void>;
  setVolume: (volume: number) => void;
  toggleMute: () => void;
  setPlayMode: (mode: PlayMode) => void;
  addToQueue: (song: Song, index?: number) => void;
  removeFromQueue: (index: number) => void;
  clearQueue: () => void;
  shuffleQueue: () => void;
  setQueue: (songs: Song[], startIndex?: number) => void;
  
  // å†…éƒ¨æ›´æ–°æ–¹æ³•
  updateCurrentTime: (time: number) => void;
  updateDuration: (duration: number) => void;
  updatePlayingState: (isPlaying: boolean) => void;
  updateLoadingState: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
}

export const usePlayerStore = create<PlayerState>()(
  devtools(
    persist(
      (set, get) => ({
        // åˆå§‹çŠ¶æ€
        currentSong: null,
        isPlaying: false,
        isPaused: false,
        isLoading: false,
        currentTime: 0,
        duration: 0,
        volume: 0.8,
        isMuted: false,
        playMode: PlayMode.SEQUENCE,
        error: null,
        queue: [],
        currentIndex: -1,
        
        // Actions
        play: async (song?: Song) => {
          const state = get();
          
          if (song) {
            // æ’­æ”¾æŒ‡å®šæ­Œæ›²
            set({ isLoading: true, error: null });
            
            try {
              await audioService.play(song);
              set({
                currentSong: song,
                isPlaying: true,
                isPaused: false,
                isLoading: false,
              });
            } catch (error) {
              set({
                isLoading: false,
                error: (error as Error).message,
              });
            }
          } else {
            // ç»§ç»­æ’­æ”¾å½“å‰æ­Œæ›²
            if (state.currentSong) {
              try {
                await audioService.play();
                set({ isPlaying: true, isPaused: false });
              } catch (error) {
                set({ error: (error as Error).message });
              }
            }
          }
        },
        
        pause: () => {
          audioService.pause();
          set({ isPlaying: false, isPaused: true });
        },
        
        stop: () => {
          audioService.stop();
          set({ 
            isPlaying: false, 
            isPaused: false, 
            currentTime: 0 
          });
        },
        
        seek: (time: number) => {
          audioService.seek(time);
          set({ currentTime: time });
        },
        
        next: async () => {
          try {
            await audioService.playNext();
            const newSong = audioService.getCurrentSong();
            set({ 
              currentSong: newSong,
              currentIndex: get().queue.findIndex(s => s?.id === newSong?.id)
            });
          } catch (error) {
            set({ error: (error as Error).message });
          }
        },
        
        previous: async () => {
          try {
            await audioService.playPrevious();
            const newSong = audioService.getCurrentSong();
            set({ 
              currentSong: newSong,
              currentIndex: get().queue.findIndex(s => s?.id === newSong?.id)
            });
          } catch (error) {
            set({ error: (error as Error).message });
          }
        },
        
        setVolume: (volume: number) => {
          audioService.setVolume(volume);
          set({ volume, isMuted: false });
        },
        
        toggleMute: () => {
          const { isMuted } = get();
          audioService.setMuted(!isMuted);
          set({ isMuted: !isMuted });
        },
        
        setPlayMode: (mode: PlayMode) => {
          audioService.setPlayMode(mode);
          set({ playMode: mode });
        },
        
        addToQueue: (song: Song, index?: number) => {
          audioService.addToQueue(song, index);
          const newQueue = audioService.getQueue();
          set({ queue: newQueue });
        },
        
        removeFromQueue: (index: number) => {
          audioService.removeFromQueue(index);
          const newQueue = audioService.getQueue();
          set({ queue: newQueue });
        },
        
        clearQueue: () => {
          audioService.clearQueue();
          set({ 
            queue: [], 
            currentSong: null, 
            currentIndex: -1,
            isPlaying: false,
            isPaused: false 
          });
        },
        
        shuffleQueue: () => {
          audioService.shuffleQueue();
          const newQueue = audioService.getQueue();
          set({ queue: newQueue });
        },
        
        setQueue: (songs: Song[], startIndex = 0) => {
          audioService.setQueue(songs, startIndex);
          const newQueue = audioService.getQueue();
          set({ 
            queue: newQueue,
            currentIndex: startIndex 
          });
        },
        
        // å†…éƒ¨æ›´æ–°æ–¹æ³•
        updateCurrentTime: (time: number) => set({ currentTime: time }),
        updateDuration: (duration: number) => set({ duration }),
        updatePlayingState: (isPlaying: boolean) => set({ isPlaying }),
        updateLoadingState: (isLoading: boolean) => set({ isLoading }),
        setError: (error: string | null) => set({ error }),
      }),
      {
        name: 'player-store',
        partialize: (state) => ({
          volume: state.volume,
          isMuted: state.isMuted,
          playMode: state.playMode,
        }),
      }
    )
  )
);

// åˆå§‹åŒ–éŸ³é¢‘æœåŠ¡äº‹ä»¶ç›‘å¬
const initializeAudioListeners = () => {
  const store = usePlayerStore.getState();
  
  audioService.addEventListener('timeupdate', () => {
    store.updateCurrentTime(audioService.getCurrentTime());
  });
  
  audioService.addEventListener('loadeddata', () => {
    store.updateDuration(audioService.getDuration());
  });
  
  audioService.addEventListener('play', () => {
    store.updatePlayingState(true);
  });
  
  audioService.addEventListener('pause', () => {
    store.updatePlayingState(false);
  });
  
  audioService.addEventListener('ended', () => {
    store.updatePlayingState(false);
  });
  
  audioService.addEventListener('error', () => {
    store.setError('æ’­æ”¾é”™è¯¯');
    store.updateLoadingState(false);
  });
};

// åœ¨åº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨
export { initializeAudioListeners };
```

### 4.2 éŸ³ä¹APIæœåŠ¡å±‚

#### æ­¥éª¤4.2.1: åˆ›å»ºAPIæŠ½è±¡å±‚
åˆ›å»º `src/services/api/MusicAPIBase.ts`:
```typescript
import { Song, Album, Artist, Playlist, SearchResult, AudioQuality } from '../../types';

// æŠ½è±¡éŸ³ä¹APIæ¥å£
export abstract class MusicAPIBase {
  protected baseUrl: string;
  protected rateLimiter?: RateLimiter;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  // æœç´¢åŠŸèƒ½
  abstract search(
    keyword: string, 
    type: 'song' | 'album' | 'artist' | 'playlist',
    page?: number,
    pageSize?: number
  ): Promise<SearchResult>;
  
  // è·å–æ­Œæ›²è¯¦æƒ…
  abstract getSongDetail(songId: string): Promise<Song>;
  
  // è·å–æ’­æ”¾é“¾æ¥
  abstract getSongUrl(songId: string, quality?: AudioQuality): Promise<string>;
  
  // è·å–æ­Œè¯
  abstract getLyrics(songId: string): Promise<{ lyrics: string; translation?: string }>;
  
  // è·å–ä¸“è¾‘ä¿¡æ¯
  abstract getAlbum(albumId: string): Promise<Album>;
  
  // è·å–è‰ºæœ¯å®¶ä¿¡æ¯
  abstract getArtist(artistId: string): Promise<Artist>;
  
  // è·å–æ­Œå•ä¿¡æ¯
  abstract getPlaylist(playlistId: string): Promise<Playlist>;
  
  // æ¨èå’Œæ’è¡Œæ¦œ
  abstract getRecommendSongs(limit?: number): Promise<Song[]>;
  abstract getTopPlaylists(category?: string, limit?: number): Promise<Playlist[]>;
  abstract getTopSongs(type?: 'new' | 'hot', limit?: number): Promise<Song[]>;
  
  // é”™è¯¯å¤„ç†
  protected handleError(error: any, context: string): never {
    console.error(`API Error in ${context}:`, error);
    throw new Error(`${context} failed: ${error.message || 'Unknown error'}`);
  }
  
  // è¯·æ±‚å·¥å…·æ–¹æ³•
  protected async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        ...options,
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      return data;
    } catch (error) {
      this.handleError(error, `Request to ${endpoint}`);
    }
  }
}

// è¯·æ±‚é™æµå™¨
export class RateLimiter {
  private requests: number[] = [];
  private maxRequests: number;
  private timeWindow: number;
  
  constructor(maxRequests: number, timeWindowMs: number) {
    this.maxRequests = maxRequests;
    this.timeWindow = timeWindowMs;
  }
  
  async wait(): Promise<void> {
    const now = Date.now();
    
    // æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
    this.requests = this.requests.filter(time => now - time < this.timeWindow);
    
    if (this.requests.length >= this.maxRequests) {
      // éœ€è¦ç­‰å¾…
      const oldestRequest = Math.min(...this.requests);
      const waitTime = this.timeWindow - (now - oldestRequest);
      
      if (waitTime > 0) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    this.requests.push(now);
  }
}
```

#### æ­¥éª¤4.2.2: å®ç°QQéŸ³ä¹API
åˆ›å»º `src/services/api/QQMusicAPI.ts`:
```typescript
import { MusicAPIBase } from './MusicAPIBase';
import { Song, Album, Artist, Playlist, SearchResult, MusicSource, AudioQuality } from '../../types';

export class QQMusicAPI extends MusicAPIBase {
  constructor() {
    super('https://api.qq.jsososo.com');
  }
  
  async search(
    keyword: string,
    type: 'song' | 'album' | 'artist' | 'playlist',
    page = 1,
    pageSize = 20
  ): Promise<SearchResult> {
    const typeMap = {
      song: 0,
      album: 8,
      artist: 9,
      playlist: 3
    };
    
    const data = await this.request('/search', {
      method: 'POST',
      body: JSON.stringify({
        key: keyword,
        pageNo: page,
        pageSize,
        t: typeMap[type]
      })
    });
    
    return this.transformSearchResult(data, type);
  }
  
  async getSongDetail(songId: string): Promise<Song> {
    const data = await this.request(`/song?songmid=${songId}`);
    return this.transformSong(data);
  }
  
  async getSongUrl(songId: string, quality = AudioQuality.STANDARD): Promise<string> {
    const data = await this.request(`/song/url?id=${songId}&quality=${quality}`);
    
    if (!data.url) {
      throw new Error('Unable to get song URL');
    }
    
    return data.url;
  }
  
  async getLyrics(songId: string): Promise<{ lyrics: string; translation?: string }> {
    const data = await this.request(`/lyric?songmid=${songId}`);
    
    return {
      lyrics: data.lyric || '',
      translation: data.trans || undefined
    };
  }
  
  async getAlbum(albumId: string): Promise<Album> {
    const data = await this.request(`/album?albummid=${albumId}`);
    return this.transformAlbum(data);
  }
  
  async getArtist(artistId: string): Promise<Artist> {
    const data = await this.request(`/artist?singermid=${artistId}`);
    return this.transformArtist(data);
  }
  
  async getPlaylist(playlistId: string): Promise<Playlist> {
    const data = await this.request(`/playlist?id=${playlistId}`);
    return this.transformPlaylist(data);
  }
  
  async getRecommendSongs(limit = 30): Promise<Song[]> {
    const data = await this.request(`/recommend?limit=${limit}`);
    return data.list.map((item: any) => this.transformSong(item));
  }
  
  async getTopPlaylists(category = '', limit = 20): Promise<Playlist[]> {
    const data = await this.request(`/top/playlist?cat=${category}&limit=${limit}`);
    return data.list.map((item: any) => this.transformPlaylist(item));
  }
  
  async getTopSongs(type = 'new', limit = 100): Promise<Song[]> {
    const data = await this.request(`/top/song?type=${type}&limit=${limit}`);
    return data.list.map((item: any) => this.transformSong(item));
  }
  
  // æ•°æ®è½¬æ¢æ–¹æ³•
  private transformSearchResult(data: any, type: string): SearchResult {
    const result: SearchResult = {
      songs: [],
      albums: [],
      artists: [],
      playlists: [],
      total: data.total || 0,
      page: data.pageNo || 1,
      pageSize: data.pageSize || 20
    };
    
    if (data.list) {
      switch (type) {
        case 'song':
          result.songs = data.list.map((item: any) => this.transformSong(item));
          break;
        case 'album':
          result.albums = data.list.map((item: any) => this.transformAlbum(item));
          break;
        case 'artist':
          result.artists = data.list.map((item: any) => this.transformArtist(item));
          break;
        case 'playlist':
          result.playlists = data.list.map((item: any) => this.transformPlaylist(item));
          break;
      }
    }
    
    return result;
  }
  
  private transformSong(item: any): Song {
    return {
      id: item.songmid || item.id,
      title: item.songname || item.name,
      artist: Array.isArray(item.singer) 
        ? item.singer.map((s: any) => s.name).join('/')
        : item.singer || item.artist,
      album: item.albumname || item.album,
      duration: item.interval || item.duration || 0,
      coverUrl: item.albummid 
        ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${item.albummid}.jpg`
        : '',
      source: MusicSource.QQ_MUSIC,
      quality: AudioQuality.STANDARD
    };
  }
  
  private transformAlbum(item: any): Album {
    return {
      id: item.albummid || item.id,
      title: item.albumname || item.name,
      artist: item.singername || item.artist,
      coverUrl: item.albummid 
        ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${item.albummid}.jpg`
        : '',
      releaseDate: new Date(item.aDate || Date.now()),
      songs: item.list ? item.list.map((song: any) => this.transformSong(song)) : [],
      source: MusicSource.QQ_MUSIC
    };
  }
  
  private transformArtist(item: any): Artist {
    return {
      id: item.singermid || item.id,
      name: item.singername || item.name,
      avatarUrl: item.singermid 
        ? `https://y.gtimg.cn/music/photo_new/T001R150x150M000${item.singermid}.jpg`
        : '',
      description: item.desc || '',
      albums: item.albumlist ? item.albumlist.map((album: any) => this.transformAlbum(album)) : [],
      topSongs: item.songlist ? item.songlist.map((song: any) => this.transformSong(song)) : [],
      source: MusicSource.QQ_MUSIC
    };
  }
  
  private transformPlaylist(item: any): Playlist {
    return {
      id: item.dissid || item.id,
      title: item.dissname || item.name,
      description: item.desc || '',
      coverUrl: item.logo || '',
      creator: item.nickname || item.creator,
      songs: item.songlist ? item.songlist.map((song: any) => this.transformSong(song)) : [],
      isPublic: true,
      createdAt: new Date(item.createtime || Date.now()),
      updatedAt: new Date(item.createtime || Date.now())
    };
  }
}
```

### 4.3 æ•°æ®ç¼“å­˜æœåŠ¡

#### æ­¥éª¤4.3.1: åˆ›å»ºç¼“å­˜ç®¡ç†å™¨
åˆ›å»º `src/services/cache/CacheManager.ts`:
```typescript
interface CacheItem<T = any> {
  data: T;
  timestamp: number;
  ttl: number;
  size: number;
  accessCount: number;
  lastAccessed: number;
}

interface CacheConfig {
  maxMemorySize?: number;
  defaultTTL?: number;
  persistentTTL?: number;
}

export class CacheManager {
  private memoryCache = new Map<string, CacheItem>();
  private readonly maxMemorySize: number;
  private readonly defaultTTL: number;
  private readonly persistentTTL: number;
  private currentMemorySize = 0;
  
  constructor(config: CacheConfig = {}) {
    this.maxMemorySize = config.maxMemorySize || 50 * 1024 * 1024; // 50MB
    this.defaultTTL = config.defaultTTL || 5 * 60 * 1000; // 5åˆ†é’Ÿ
    this.persistentTTL = config.persistentTTL || 60 * 60 * 1000; // 1å°æ—¶
  }
  
  // è·å–ç¼“å­˜æ•°æ®
  async get<T>(key: string): Promise<T | null> {
    // ä¼˜å…ˆä»å†…å­˜ç¼“å­˜è·å–
    const memoryItem = this.memoryCache.get(key);
    if (memoryItem && !this.isExpired(memoryItem)) {
      memoryItem.accessCount++;
      memoryItem.lastAccessed = Date.now();
      return memoryItem.data;
    }
    
    // ä»æŒä¹…åŒ–å­˜å‚¨è·å–
    try {
      const persistentData = await this.getFromPersistentStorage(key);
      if (persistentData && !this.isExpired(persistentData)) {
        // é‡æ–°æ”¾å…¥å†…å­˜ç¼“å­˜
        this.setInMemory(key, persistentData.data, persistentData.ttl);
        return persistentData.data;
      }
    } catch (error) {
      console.warn('Failed to get from persistent storage:', error);
    }
    
    return null;
  }
  
  // è®¾ç½®ç¼“å­˜æ•°æ®
  async set<T>(key: string, data: T, ttl?: number): Promise<void> {
    const cacheTTL = ttl || this.defaultTTL;
    
    // è®¾ç½®å†…å­˜ç¼“å­˜
    this.setInMemory(key, data, cacheTTL);
    
    // é•¿æœŸç¼“å­˜å­˜å‚¨åˆ°æŒä¹…åŒ–å­˜å‚¨
    if (cacheTTL >= this.persistentTTL) {
      try {
        await this.setToPersistentStorage(key, data, cacheTTL);
      } catch (error) {
        console.warn('Failed to set to persistent storage:', error);
      }
    }
  }
  
  // åˆ é™¤ç¼“å­˜
  async delete(key: string): Promise<void> {
    this.memoryCache.delete(key);
    
    try {
      await this.deleteFromPersistentStorage(key);
    } catch (error) {
      console.warn('Failed to delete from persistent storage:', error);
    }
  }
  
  // æ¸…ç©ºç¼“å­˜
  async clear(): Promise<void> {
    this.memoryCache.clear();
    this.currentMemorySize = 0;
    
    try {
      await this.clearPersistentStorage();
    } catch (error) {
      console.warn('Failed to clear persistent storage:', error);
    }
  }
  
  // æ£€æŸ¥æ˜¯å¦å­˜åœ¨
  async has(key: string): Promise<boolean> {
    const data = await this.get(key);
    return data !== null;
  }
  
  // è®¾ç½®å†…å­˜ç¼“å­˜
  private setInMemory<T>(key: string, data: T, ttl: number): void {
    const size = JSON.stringify(data).length * 2; // ä¼°ç®—å¤§å°
    
    const item: CacheItem<T> = {
      data,
      timestamp: Date.now(),
      ttl,
      size,
      accessCount: 1,
      lastAccessed: Date.now()
    };
    
    // åˆ é™¤æ—§é¡¹ç›®
    const oldItem = this.memoryCache.get(key);
    if (oldItem) {
      this.currentMemorySize -= oldItem.size;
    }
    
    this.memoryCache.set(key, item);
    this.currentMemorySize += size;
    
    // æ£€æŸ¥å†…å­˜é™åˆ¶
    this.evictIfNecessary();
  }
  
  // LRUå†…å­˜æ·˜æ±°ç­–ç•¥
  private evictIfNecessary(): void {
    if (this.currentMemorySize <= this.maxMemorySize) return;
    
    // æŒ‰è®¿é—®æ—¶é—´æ’åºï¼Œä¼˜å…ˆæ·˜æ±°æœ€ä¹…æœªè®¿é—®çš„
    const entries = Array.from(this.memoryCache.entries())
      .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);
    
    for (const [key, item] of entries) {
      this.memoryCache.delete(key);
      this.currentMemorySize -= item.size;
      
      if (this.currentMemorySize <= this.maxMemorySize * 0.8) {
        break;
      }
    }
  }
  
  // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
  private isExpired(item: CacheItem): boolean {
    return Date.now() - item.timestamp > item.ttl;
  }
  
  // æŒä¹…åŒ–å­˜å‚¨æ–¹æ³• (ä½¿ç”¨ localStorage)
  private async getFromPersistentStorage(key: string): Promise<CacheItem | null> {
    try {
      const item = localStorage.getItem(`cache_${key}`);
      return item ? JSON.parse(item) : null;
    } catch {
      return null;
    }
  }
  
  private async setToPersistentStorage<T>(key: string, data: T, ttl: number): Promise<void> {
    const item: CacheItem<T> = {
      data,
      timestamp: Date.now(),
      ttl,
      size: 0,
      accessCount: 0,
      lastAccessed: Date.now()
    };
    
    try {
      localStorage.setItem(`cache_${key}`, JSON.stringify(item));
    } catch (error) {
      // å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œæ¸…ç†ä¸€äº›è¿‡æœŸé¡¹ç›®
      this.cleanupPersistentStorage();
      throw error;
    }
  }
  
  private async deleteFromPersistentStorage(key: string): Promise<void> {
    localStorage.removeItem(`cache_${key}`);
  }
  
  private async clearPersistentStorage(): Promise<void> {
    const keys = Object.keys(localStorage).filter(key => key.startsWith('cache_'));
    keys.forEach(key => localStorage.removeItem(key));
  }
  
  private cleanupPersistentStorage(): void {
    const now = Date.now();
    const keys = Object.keys(localStorage).filter(key => key.startsWith('cache_'));
    
    for (const key of keys) {
      try {
        const item = JSON.parse(localStorage.getItem(key) || '');
        if (now - item.timestamp > item.ttl) {
          localStorage.removeItem(key);
        }
      } catch {
        localStorage.removeItem(key);
      }
    }
  }
  
  // è·å–ç¼“å­˜ç»Ÿè®¡
  getStats() {
    const memoryEntries = Array.from(this.memoryCache.values());
    
    return {
      memoryItems: memoryEntries.length,
      memorySize: this.currentMemorySize,
      maxMemorySize: this.maxMemorySize,
      hitRate: memoryEntries.length > 0 
        ? memoryEntries.reduce((sum, item) => sum + item.accessCount, 0) / memoryEntries.length 
        : 0
    };
  }
}

// å•ä¾‹ç¼“å­˜ç®¡ç†å™¨
export const cacheManager = new CacheManager();
```

### 4.4 APIèšåˆæœåŠ¡

#### æ­¥éª¤4.4.1: åˆ›å»ºç»Ÿä¸€éŸ³ä¹æœåŠ¡
åˆ›å»º `src/services/api/MusicService.ts`:
```typescript
import { QQMusicAPI } from './QQMusicAPI';
import { MusicAPIBase } from './MusicAPIBase';
import { cacheManager } from '../cache/CacheManager';
import { 
  Song, 
  Album, 
  Artist, 
  Playlist, 
  SearchResult, 
  MusicSource,
  AudioQuality 
} from '../../types';

interface SearchOptions {
  page?: number;
  pageSize?: number;
  source?: MusicSource;
}

export class MusicService {
  private apis: Map<MusicSource, MusicAPIBase> = new Map();
  private fallbackOrder: MusicSource[] = [
    MusicSource.QQ_MUSIC,
    // å…¶ä»–APIå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
  ];
  
  constructor() {
    this.apis.set(MusicSource.QQ_MUSIC, new QQMusicAPI());
  }
  
  // æœç´¢éŸ³ä¹
  async search(
    keyword: string,
    type: 'song' | 'album' | 'artist' | 'playlist' = 'song',
    options: SearchOptions = {}
  ): Promise<SearchResult> {
    const cacheKey = `search_${keyword}_${type}_${options.page || 1}_${options.pageSize || 20}`;
    
    // å°è¯•ä»ç¼“å­˜è·å–
    const cached = await cacheManager.get<SearchResult>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const errors: Error[] = [];
    const targetSources = options.source ? [options.source] : this.fallbackOrder;
    
    for (const source of targetSources) {
      try {
        const api = this.apis.get(source);
        if (api) {
          const result = await api.search(keyword, type, options.page, options.pageSize);
          
          if (result.total > 0) {
            // ç¼“å­˜ç»“æœ (5åˆ†é’Ÿ)
            await cacheManager.set(cacheKey, result, 5 * 60 * 1000);
            return result;
          }
        }
      } catch (error) {
        errors.push(error as Error);
        console.warn(`Search failed for source ${source}:`, error);
      }
    }
    
    // æ‰€æœ‰APIéƒ½å¤±è´¥äº†
    throw new Error(`All search APIs failed: ${errors.map(e => e.message).join(', ')}`);
  }
  
  // è·å–æ­Œæ›²è¯¦æƒ…
  async getSongDetail(songId: string, source?: MusicSource): Promise<Song> {
    const cacheKey = `song_detail_${songId}`;
    
    const cached = await cacheManager.get<Song>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const targetSources = source ? [source] : this.fallbackOrder;
    
    for (const src of targetSources) {
      try {
        const api = this.apis.get(src);
        if (api) {
          const song = await api.getSongDetail(songId);
          
          // ç¼“å­˜ç»“æœ (30åˆ†é’Ÿ)
          await cacheManager.set(cacheKey, song, 30 * 60 * 1000);
          return song;
        }
      } catch (error) {
        console.warn(`Get song detail failed for source ${src}:`, error);
      }
    }
    
    throw new Error(`Failed to get song detail for ${songId}`);
  }
  
  // è·å–æ’­æ”¾é“¾æ¥
  async getSongUrl(songId: string, quality = AudioQuality.STANDARD, source?: MusicSource): Promise<string> {
    const cacheKey = `song_url_${songId}_${quality}`;
    
    // URLç¼“å­˜æ—¶é—´è¾ƒçŸ­ (5åˆ†é’Ÿ)
    const cached = await cacheManager.get<string>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const targetSources = source ? [source] : this.fallbackOrder;
    
    for (const src of targetSources) {
      try {
        const api = this.apis.get(src);
        if (api) {
          const url = await api.getSongUrl(songId, quality);
          
          if (url) {
            // ç¼“å­˜URL (5åˆ†é’Ÿ)
            await cacheManager.set(cacheKey, url, 5 * 60 * 1000);
            return url;
          }
        }
      } catch (error) {
        console.warn(`Get song URL failed for source ${src}:`, error);
      }
    }
    
    throw new Error(`Failed to get song URL for ${songId}`);
  }
  
  // è·å–æ­Œè¯
  async getLyrics(songId: string, source?: MusicSource): Promise<{ lyrics: string; translation?: string }> {
    const cacheKey = `lyrics_${songId}`;
    
    const cached = await cacheManager.get<{ lyrics: string; translation?: string }>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const targetSources = source ? [source] : this.fallbackOrder;
    
    for (const src of targetSources) {
      try {
        const api = this.apis.get(src);
        if (api) {
          const lyrics = await api.getLyrics(songId);
          
          if (lyrics.lyrics) {
            // ç¼“å­˜æ­Œè¯ (1å°æ—¶)
            await cacheManager.set(cacheKey, lyrics, 60 * 60 * 1000);
            return lyrics;
          }
        }
      } catch (error) {
        console.warn(`Get lyrics failed for source ${src}:`, error);
      }
    }
    
    return { lyrics: '' }; // è¿”å›ç©ºæ­Œè¯è€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯
  }
  
  // è·å–æ¨èæ­Œæ›²
  async getRecommendSongs(limit = 30): Promise<Song[]> {
    const cacheKey = `recommend_songs_${limit}`;
    
    const cached = await cacheManager.get<Song[]>(cacheKey);
    if (cached) {
      return cached;
    }
    
    for (const source of this.fallbackOrder) {
      try {
        const api = this.apis.get(source);
        if (api) {
          const songs = await api.getRecommendSongs(limit);
          
          if (songs.length > 0) {
            // ç¼“å­˜æ¨èç»“æœ (30åˆ†é’Ÿ)
            await cacheManager.set(cacheKey, songs, 30 * 60 * 1000);
            return songs;
          }
        }
      } catch (error) {
        console.warn(`Get recommend songs failed for source ${source}:`, error);
      }
    }
    
    return []; // è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯
  }
  
  // è·å–çƒ­é—¨æ­Œå•
  async getTopPlaylists(category = '', limit = 20): Promise<Playlist[]> {
    const cacheKey = `top_playlists_${category}_${limit}`;
    
    const cached = await cacheManager.get<Playlist[]>(cacheKey);
    if (cached) {
      return cached;
    }
    
    for (const source of this.fallbackOrder) {
      try {
        const api = this.apis.get(source);
        if (api) {
          const playlists = await api.getTopPlaylists(category, limit);
          
          if (playlists.length > 0) {
            // ç¼“å­˜æ¦œå• (1å°æ—¶)
            await cacheManager.set(cacheKey, playlists, 60 * 60 * 1000);
            return playlists;
          }
        }
      } catch (error) {
        console.warn(`Get top playlists failed for source ${source}:`, error);
      }
    }
    
    return [];
  }
  
  // æ¸…é™¤ç¼“å­˜
  async clearCache(): Promise<void> {
    await cacheManager.clear();
  }
  
  // è·å–ç¼“å­˜ç»Ÿè®¡
  getCacheStats() {
    return cacheManager.getStats();
  }
}

// å•ä¾‹éŸ³ä¹æœåŠ¡
export const musicService = new MusicService();
```

### 4.5 éªŒæ”¶æ ‡å‡†

#### é˜¶æ®µ4å®Œæˆæ£€æŸ¥æ¸…å•ï¼š
- [ ] âœ… ZustandçŠ¶æ€ç®¡ç†æ­£å¸¸å·¥ä½œ
- [ ] âœ… éŸ³é¢‘æœåŠ¡ä¸çŠ¶æ€ç®¡ç†é›†æˆå®Œæˆ
- [ ] âœ… éŸ³ä¹APIæŠ½è±¡å±‚è®¾è®¡å®Œæ•´
- [ ] âœ… QQéŸ³ä¹APIé›†æˆå¹¶èƒ½æ­£å¸¸æœç´¢å’Œæ’­æ”¾
- [ ] âœ… ç¼“å­˜ç®¡ç†å™¨åŠŸèƒ½å®Œæ•´
- [ ] âœ… APIèšåˆæœåŠ¡æ”¯æŒå¤šæ•°æ®æº
- [ ] âœ… é”™è¯¯å¤„ç†å’Œé™çº§ç­–ç•¥å®Œå–„

---

## ğŸ¨ é˜¶æ®µ5: é«˜çº§åŠŸèƒ½å¼€å‘ (ç¬¬10-11å‘¨)

### 5.1 æ­Œè¯æ˜¾ç¤ºåŠŸèƒ½

#### æ­¥éª¤5.1.1: åˆ›å»ºæ­Œè¯è§£æå™¨
åˆ›å»º `src/services/lyrics/LyricsParser.ts`:
```typescript
export interface ParsedLyricLine {
  time: number;
  text: string;
  translation?: string;
}

export interface ParsedLyrics {
  lines: ParsedLyricLine[];
  offset: number;
  duration: number;
}

export class LyricsParser {
  // è§£æLRCæ ¼å¼æ­Œè¯
  static parseLRC(lrcText: string, translation?: string): ParsedLyrics {
    const lines: ParsedLyricLine[] = [];
    const lrcLines = lrcText.split('\n');
    const translationLines = translation ? translation.split('\n') : [];
    
    let offset = 0;
    let duration = 0;
    
    // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ—¶é—´æ ‡ç­¾
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
    const offsetRegex = /\[offset:(-?\d+)\]/;
    
    for (let i = 0; i < lrcLines.length; i++) {
      const line = lrcLines[i].trim();
      
      // è§£æoffset
      const offsetMatch = line.match(offsetRegex);
      if (offsetMatch) {
        offset = parseInt(offsetMatch[1]);
        continue;
      }
      
      // è§£ææ­Œè¯è¡Œ
      let match;
      const times: number[] = [];
      let text = line;
      
      // æå–æ‰€æœ‰æ—¶é—´æ ‡ç­¾
      while ((match = timeRegex.exec(line)) !== null) {
        const minutes = parseInt(match[1]);
        const seconds = parseInt(match[2]);
        const milliseconds = parseInt(match[3].padEnd(3, '0'));
        const totalMs = minutes * 60 * 1000 + seconds * 1000 + milliseconds;
        times.push(totalMs);
      }
      
      // ç§»é™¤æ—¶é—´æ ‡ç­¾ï¼Œè·å–æ­Œè¯æ–‡æœ¬
      text = line.replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim();
      
      // å¦‚æœæœ‰æ­Œè¯æ–‡æœ¬å’Œæ—¶é—´ï¼Œæ·»åŠ åˆ°ç»“æœä¸­
      if (text && times.length > 0) {
        const translationText = translationLines[i] 
          ? translationLines[i].replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim()
          : undefined;
        
        times.forEach(time => {
          lines.push({
            time: time + offset,
            text,
            translation: translationText || undefined
          });
          
          duration = Math.max(duration, time + offset);
        });
      }
    }
    
    // æŒ‰æ—¶é—´æ’åº
    lines.sort((a, b) => a.time - b.time);
    
    return {
      lines,
      offset,
      duration
    };
  }
  
  // æŸ¥æ‰¾å½“å‰æ—¶é—´å¯¹åº”çš„æ­Œè¯è¡Œ
  static getCurrentLine(lyrics: ParsedLyrics, currentTime: number): ParsedLyricLine | null {
    if (!lyrics.lines.length) return null;
    
    // è½¬æ¢ä¸ºæ¯«ç§’
    const timeMs = currentTime * 1000;
    
    let currentLine: ParsedLyricLine | null = null;
    
    for (const line of lyrics.lines) {
      if (line.time <= timeMs) {
        currentLine = line;
      } else {
        break;
      }
    }
    
    return currentLine;
  }
  
  // è·å–æ­Œè¯æ»šåŠ¨ä½ç½®
  static getScrollPosition(
    lyrics: ParsedLyrics, 
    currentTime: number, 
    containerHeight: number, 
    lineHeight: number
  ): number {
    const currentLine = this.getCurrentLine(lyrics, currentTime);
    if (!currentLine) return 0;
    
    const currentIndex = lyrics.lines.indexOf(currentLine);
    const visibleLines = Math.floor(containerHeight / lineHeight);
    const centerLine = Math.floor(visibleLines / 2);
    
    const scrollToIndex = Math.max(0, currentIndex - centerLine);
    return scrollToIndex * lineHeight;
  }
}
```

#### æ­¥éª¤5.1.2: åˆ›å»ºæ­Œè¯æ˜¾ç¤ºç»„ä»¶
åˆ›å»º `src/components/player/LyricsDisplay.tsx`:
```typescript
import React, { useState, useEffect, useRef } from 'react';
import { musicService } from '../../services/api/MusicService';
import { LyricsParser, ParsedLyrics, ParsedLyricLine } from '../../services/lyrics/LyricsParser';
import { cn } from '../../utils';

interface LyricsDisplayProps {
  songId: string;
  currentTime: number;
  className?: string;
  showTranslation?: boolean;
  fontSize?: 'sm' | 'md' | 'lg';
  centered?: boolean;
}

export const LyricsDisplay: React.FC<LyricsDisplayProps> = ({
  songId,
  currentTime,
  className,
  showTranslation = false,
  fontSize = 'md',
  centered = false,
}) => {
  const [lyrics, setLyrics] = useState<ParsedLyrics | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentLine, setCurrentLine] = useState<ParsedLyricLine | null>(null);
  
  const containerRef = useRef<HTMLDivElement>(null);
  const currentLineRef = useRef<HTMLDivElement>(null);
  
  const lineHeight = fontSize === 'sm' ? 32 : fontSize === 'md' ? 40 : 48;
  
  // åŠ è½½æ­Œè¯
  useEffect(() => {
    if (!songId) return;
    
    const loadLyrics = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const lyricsData = await musicService.getLyrics(songId);
        
        if (lyricsData.lyrics) {
          const parsed = LyricsParser.parseLRC(
            lyricsData.lyrics, 
            showTranslation ? lyricsData.translation : undefined
          );
          setLyrics(parsed);
        } else {
          setLyrics(null);
          setError('æš‚æ— æ­Œè¯');
        }
      } catch (err) {
        setError('æ­Œè¯åŠ è½½å¤±è´¥');
        console.error('Failed to load lyrics:', err);
      } finally {
        setLoading(false);
      }
    };
    
    loadLyrics();
  }, [songId, showTranslation]);
  
  // æ›´æ–°å½“å‰æ­Œè¯è¡Œ
  useEffect(() => {
    if (!lyrics) return;
    
    const current = LyricsParser.getCurrentLine(lyrics, currentTime);
    setCurrentLine(current);
  }, [lyrics, currentTime]);
  
  // è‡ªåŠ¨æ»šåŠ¨
  useEffect(() => {
    if (!lyrics || !currentLine || !containerRef.current || !currentLineRef.current) return;
    
    const container = containerRef.current;
    const currentElement = currentLineRef.current;
    
    const containerHeight = container.clientHeight;
    const scrollTop = container.scrollTop;
    const elementTop = currentElement.offsetTop;
    const elementHeight = currentElement.clientHeight;
    
    // è®¡ç®—æ˜¯å¦éœ€è¦æ»šåŠ¨
    const visibleTop = scrollTop;
    const visibleBottom = scrollTop + containerHeight;
    const elementBottom = elementTop + elementHeight;
    
    // å¦‚æœå½“å‰è¡Œä¸åœ¨å¯è§†åŒºåŸŸä¸­å¤®ï¼Œæ»šåŠ¨åˆ°ä¸­å¤®
    const centerPosition = elementTop - containerHeight / 2 + elementHeight / 2;
    
    if (elementTop < visibleTop + containerHeight * 0.3 || 
        elementBottom > visibleBottom - containerHeight * 0.3) {
      container.scrollTo({
        top: Math.max(0, centerPosition),
        behavior: 'smooth'
      });
    }
  }, [currentLine]);
  
  if (loading) {
    return (
      <div className={cn('flex items-center justify-center h-32', className)}>
        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-netease"></div>
        <span className="ml-2 text-gray-500">åŠ è½½æ­Œè¯ä¸­...</span>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className={cn('flex items-center justify-center h-32 text-gray-500', className)}>
        {error}
      </div>
    );
  }
  
  if (!lyrics || !lyrics.lines.length) {
    return (
      <div className={cn('flex items-center justify-center h-32 text-gray-500', className)}>
        æš‚æ— æ­Œè¯
      </div>
    );
  }
  
  const fontSizeClasses = {
    sm: 'text-sm',
    md: 'text-base',
    lg: 'text-lg'
  };
  
  return (
    <div
      ref={containerRef}
      className={cn(
        'overflow-y-auto scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-transparent',
        'max-h-96 px-4 py-8',
        className
      )}
      style={{ lineHeight: `${lineHeight}px` }}
    >
      <div className={cn('space-y-2', centered && 'text-center')}>
        {lyrics.lines.map((line, index) => {
          const isCurrentLine = currentLine?.time === line.time && currentLine?.text === line.text;
          
          return (
            <div
              key={`${line.time}-${index}`}
              ref={isCurrentLine ? currentLineRef : undefined}
              className={cn(
                'transition-all duration-300 cursor-pointer hover:text-netease',
                fontSizeClasses[fontSize],
                isCurrentLine 
                  ? 'text-netease font-medium scale-105' 
                  : 'text-gray-600 hover:text-gray-800'
              )}
              style={{ minHeight: lineHeight }}
              onClick={() => {
                // ç‚¹å‡»è·³è½¬åˆ°å¯¹åº”æ—¶é—´
                const seekTime = line.time / 1000;
                // è¿™é‡Œéœ€è¦é€šè¿‡propsä¼ å…¥onSeekå›è°ƒ
                // onSeek?.(seekTime);
              }}
            >
              <div>{line.text}</div>
              {showTranslation && line.translation && (
                <div className={cn(
                  'text-gray-400 mt-1',
                  fontSize === 'sm' ? 'text-xs' : 'text-sm'
                )}>
                  {line.translation}
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

### 5.2 éŸ³é¢‘å¯è§†åŒ–

#### æ­¥éª¤5.2.1: åˆ›å»ºé¢‘è°±åˆ†æå™¨
åˆ›å»º `src/components/player/AudioVisualizer.tsx`:
```typescript
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { usePlayerStore } from '../../stores/playerStore';
import { audioService } from '../../services/audio/AudioService';
import { cn } from '../../utils';

interface AudioVisualizerProps {
  type?: 'bars' | 'wave' | 'circle';
  color?: string;
  className?: string;
  height?: number;
  sensitivity?: number;
  smoothing?: number;
}

export const AudioVisualizer: React.FC<AudioVisualizerProps> = ({
  type = 'bars',
  color = '#C62D42',
  className,
  height = 100,
  sensitivity = 1,
  smoothing = 0.8,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>();
  const [isActive, setIsActive] = useState(false);
  
  const { isPlaying } = usePlayerStore();
  
  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    const width = canvas.width;
    const height = canvas.height;
    
    // è·å–é¢‘è°±æ•°æ®
    const frequencyData = audioService.getFrequencyData();
    
    if (frequencyData.length === 0) {
      // æ²¡æœ‰éŸ³é¢‘æ•°æ®ï¼Œç»˜åˆ¶é™æ€çŠ¶æ€
      ctx.clearRect(0, 0, width, height);
      return;
    }
    
    // æ¸…ç©ºç”»å¸ƒ
    ctx.clearRect(0, 0, width, height);
    
    switch (type) {
      case 'bars':
        drawBars(ctx, frequencyData, width, height, color, sensitivity);
        break;
      case 'wave':
        drawWave(ctx, frequencyData, width, height, color, sensitivity);
        break;
      case 'circle':
        drawCircle(ctx, frequencyData, width, height, color, sensitivity);
        break;
    }
  }, [type, color, sensitivity]);
  
  const animate = useCallback(() => {
    if (!isPlaying || !isActive) {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = undefined;
      }
      return;
    }
    
    draw();
    animationRef.current = requestAnimationFrame(animate);
  }, [isPlaying, isActive, draw]);
  
  // ç›‘å¬æ’­æ”¾çŠ¶æ€
  useEffect(() => {
    setIsActive(isPlaying);
  }, [isPlaying]);
  
  // å¯åŠ¨/åœæ­¢åŠ¨ç”»
  useEffect(() => {
    if (isActive && isPlaying) {
      animate();
    } else if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = undefined;
      
      // æ¸…ç©ºç”»å¸ƒ
      const canvas = canvasRef.current;
      if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx?.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isActive, isPlaying, animate]);
  
  // è®¾ç½®canvaså°ºå¯¸
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const container = canvas.parentElement;
    if (!container) return;
    
    const updateSize = () => {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width * devicePixelRatio;
      canvas.height = height * devicePixelRatio;
      canvas.style.width = `${rect.width}px`;
      canvas.style.height = `${height}px`;
      
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.scale(devicePixelRatio, devicePixelRatio);
      }
    };
    
    updateSize();
    window.addEventListener('resize', updateSize);
    
    return () => window.removeEventListener('resize', updateSize);
  }, [height]);
  
  return (
    <div className={cn('w-full', className)} style={{ height }}>
      <canvas
        ref={canvasRef}
        className="w-full h-full"
        style={{ imageRendering: 'pixelated' }}
      />
    </div>
  );
};

// ç»˜åˆ¶æŸ±çŠ¶å›¾
function drawBars(
  ctx: CanvasRenderingContext2D,
  data: Uint8Array,
  width: number,
  height: number,
  color: string,
  sensitivity: number
) {
  const barCount = Math.min(64, data.length / 4); // å‡å°‘æŸ±å­æ•°é‡
  const barWidth = width / barCount;
  
  ctx.fillStyle = color;
  
  for (let i = 0; i < barCount; i++) {
    const dataIndex = Math.floor((i / barCount) * data.length);
    const amplitude = (data[dataIndex] / 255) * sensitivity;
    const barHeight = amplitude * height;
    
    const x = i * barWidth;
    const y = height - barHeight;
    
    // æ·»åŠ æ¸å˜æ•ˆæœ
    const gradient = ctx.createLinearGradient(0, y, 0, height);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, color + '60'); // æ·»åŠ é€æ˜åº¦
    
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, barWidth - 2, barHeight);
  }
}

// ç»˜åˆ¶æ³¢å½¢å›¾
function drawWave(
  ctx: CanvasRenderingContext2D,
  data: Uint8Array,
  width: number,
  height: number,
  color: string,
  sensitivity: number
) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  const sliceWidth = width / data.length;
  let x = 0;
  
  for (let i = 0; i < data.length; i++) {
    const amplitude = (data[i] / 255) * sensitivity;
    const y = height / 2 + (amplitude - 0.5) * height;
    
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
    
    x += sliceWidth;
  }
  
  ctx.stroke();
}

// ç»˜åˆ¶åœ†å½¢å¯è§†åŒ–
function drawCircle(
  ctx: CanvasRenderingContext2D,
  data: Uint8Array,
  width: number,
  height: number,
  color: string,
  sensitivity: number
) {
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) / 4;
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  
  const barCount = Math.min(60, data.length / 2);
  const angleStep = (Math.PI * 2) / barCount;
  
  for (let i = 0; i < barCount; i++) {
    const dataIndex = Math.floor((i / barCount) * data.length);
    const amplitude = (data[dataIndex] / 255) * sensitivity;
    const barLength = amplitude * radius;
    
    const angle = i * angleStep;
    const x1 = centerX + Math.cos(angle) * radius;
    const y1 = centerY + Math.sin(angle) * radius;
    const x2 = centerX + Math.cos(angle) * (radius + barLength);
    const y2 = centerY + Math.sin(angle) * (radius + barLength);
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
  
  // ç»˜åˆ¶ä¸­å¿ƒåœ†
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
  ctx.fillStyle = color + '40';
  ctx.fill();
}
```

### 5.3 ç”¨æˆ·æ•°æ®ç®¡ç†

#### æ­¥éª¤5.3.1: åˆ›å»ºç”¨æˆ·æ•°æ®å­˜å‚¨
åˆ›å»º `src/stores/userStore.ts`:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Song, Playlist } from '../types';

interface UserState {
  // ç”¨æˆ·æ”¶è—
  favorites: Song[];
  favoriteSongIds: Set<string>;
  
  // ç”¨æˆ·æ’­æ”¾åˆ—è¡¨
  playlists: Playlist[];
  
  // æ’­æ”¾å†å²
  recentPlayed: Song[];
  
  // ç”¨æˆ·è®¾ç½®
  settings: {
    theme: 'light' | 'dark';
    autoPlay: boolean;
    showLyrics: boolean;
    showTranslation: boolean;
    audioQuality: string;
    crossfade: boolean;
    volume: number;
  };
  
  // Actions
  addToFavorites: (song: Song) => void;
  removeFromFavorites: (songId: string) => void;
  isFavorite: (songId: string) => boolean;
  
  createPlaylist: (name: string, description?: string) => Playlist;
  deletePlaylist: (playlistId: string) => void;
  addToPlaylist: (playlistId: string, song: Song) => void;
  removeFromPlaylist: (playlistId: string, songId: string) => void;
  updatePlaylist: (playlistId: string, updates: Partial<Playlist>) => void;
  
  addToRecentPlayed: (song: Song) => void;
  clearRecentPlayed: () => void;
  
  updateSettings: (settings: Partial<UserState['settings']>) => void;
}

export const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      favorites: [],
      favoriteSongIds: new Set(),
      playlists: [],
      recentPlayed: [],
      settings: {
        theme: 'light',
        autoPlay: true,
        showLyrics: true,
        showTranslation: false,
        audioQuality: 'standard',
        crossfade: false,
        volume: 0.8,
      },
      
      // æ”¶è—ç®¡ç†
      addToFavorites: (song: Song) => {
        const state = get();
        if (!state.favoriteSongIds.has(song.id)) {
          set({
            favorites: [song, ...state.favorites],
            favoriteSongIds: new Set([...state.favoriteSongIds, song.id])
          });
        }
      },
      
      removeFromFavorites: (songId: string) => {
        const state = get();
        if (state.favoriteSongIds.has(songId)) {
          const newFavorites = state.favorites.filter(song => song.id !== songId);
          const newFavoriteIds = new Set(state.favoriteSongIds);
          newFavoriteIds.delete(songId);
          
          set({
            favorites: newFavorites,
            favoriteSongIds: newFavoriteIds
          });
        }
      },
      
      isFavorite: (songId: string) => {
        return get().favoriteSongIds.has(songId);
      },
      
      // æ’­æ”¾åˆ—è¡¨ç®¡ç†
      createPlaylist: (name: string, description = '') => {
        const playlist: Playlist = {
          id: `playlist_${Date.now()}`,
          title: name,
          description,
          coverUrl: '',
          creator: 'æˆ‘',
          songs: [],
          isPublic: false,
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        set(state => ({
          playlists: [...state.playlists, playlist]
        }));
        
        return playlist;
      },
      
      deletePlaylist: (playlistId: string) => {
        set(state => ({
          playlists: state.playlists.filter(p => p.id !== playlistId)
        }));
      },
      
      addToPlaylist: (playlistId: string, song: Song) => {
        set(state => ({
          playlists: state.playlists.map(playlist => {
            if (playlist.id === playlistId) {
              const songExists = playlist.songs.some(s => s.id === song.id);
              if (!songExists) {
                return {
                  ...playlist,
                  songs: [...playlist.songs, song],
                  updatedAt: new Date()
                };
              }
            }
            return playlist;
          })
        }));
      },
      
      removeFromPlaylist: (playlistId: string, songId: string) => {
        set(state => ({
          playlists: state.playlists.map(playlist => {
            if (playlist.id === playlistId) {
              return {
                ...playlist,
                songs: playlist.songs.filter(song => song.id !== songId),
                updatedAt: new Date()
              };
            }
            return playlist;
          })
        }));
      },
      
      updatePlaylist: (playlistId: string, updates: Partial<Playlist>) => {
        set(state => ({
          playlists: state.playlists.map(playlist => {
            if (playlist.id === playlistId) {
              return {
                ...playlist,
                ...updates,
                updatedAt: new Date()
              };
            }
            return playlist;
          })
        }));
      },
      
      // æ’­æ”¾å†å²ç®¡ç†
      addToRecentPlayed: (song: Song) => {
        set(state => {
          const filtered = state.recentPlayed.filter(s => s.id !== song.id);
          const newRecentPlayed = [song, ...filtered].slice(0, 50); // ä¿ç•™æœ€è¿‘50é¦–
          
          return {
            recentPlayed: newRecentPlayed
          };
        });
      },
      
      clearRecentPlayed: () => {
        set({ recentPlayed: [] });
      },
      
      // è®¾ç½®ç®¡ç†
      updateSettings: (newSettings: Partial<UserState['settings']>) => {
        set(state => ({
          settings: {
            ...state.settings,
            ...newSettings
          }
        }));
      },
    }),
    {
      name: 'user-store',
      partialize: (state) => ({
        favorites: state.favorites,
        favoriteSongIds: Array.from(state.favoriteSongIds), // Setéœ€è¦è½¬æ¢ä¸ºæ•°ç»„
        playlists: state.playlists,
        recentPlayed: state.recentPlayed,
        settings: state.settings,
      }),
      // æ¢å¤æ—¶é‡å»ºSet
      onRehydrateStorage: () => (state) => {
        if (state && Array.isArray(state.favoriteSongIds)) {
          state.favoriteSongIds = new Set(state.favoriteSongIds);
        }
      },
    }
  )
);
```

### 5.4 éªŒæ”¶æ ‡å‡†

#### é˜¶æ®µ5å®Œæˆæ£€æŸ¥æ¸…å•ï¼š
- [ ] âœ… æ­Œè¯è§£æå’Œæ˜¾ç¤ºåŠŸèƒ½æ­£å¸¸
- [ ] âœ… æ­Œè¯æ»šåŠ¨å’Œé«˜äº®æ•ˆæœæµç•…
- [ ] âœ… éŸ³é¢‘å¯è§†åŒ–æ•ˆæœç¾è§‚
- [ ] âœ… ç”¨æˆ·æ”¶è—åŠŸèƒ½å®Œæ•´
- [ ] âœ… æ’­æ”¾åˆ—è¡¨ç®¡ç†åŠŸèƒ½æ­£å¸¸
- [ ] âœ… æ’­æ”¾å†å²è®°å½•æ­£å¸¸
- [ ] âœ… ç”¨æˆ·è®¾ç½®æŒä¹…åŒ–æ­£å¸¸

---

## ğŸ“± é˜¶æ®µ6: ç§»åŠ¨ç«¯ä¼˜åŒ– (ç¬¬12-13å‘¨)

### 6.1 å“åº”å¼å¸ƒå±€é€‚é…

#### æ­¥éª¤6.1.1: åˆ›å»ºå“åº”å¼Hook
åˆ›å»º `src/hooks/useResponsive.ts`:
```typescript
import { useState, useEffect } from 'react';

export interface BreakpointConfig {
  sm: number;
  md: number;
  lg: number;
  xl: number;
  '2xl': number;
}

const defaultBreakpoints: BreakpointConfig = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  '2xl': 1536,
};

export type ScreenSize = keyof BreakpointConfig;

export interface ResponsiveState {
  screenSize: ScreenSize;
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
  width: number;
  height: number;
}

export const useResponsive = (breakpoints: BreakpointConfig = defaultBreakpoints): ResponsiveState => {
  const [state, setState] = useState<ResponsiveState>(() => {
    if (typeof window === 'undefined') {
      return {
        screenSize: 'lg',
        isMobile: false,
        isTablet: false,
        isDesktop: true,
        width: 1024,
        height: 768,
      };
    }
    
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    return {
      ...getScreenInfo(width, breakpoints),
      width,
      height,
    };
  });
  
  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      setState({
        ...getScreenInfo(width, breakpoints),
        width,
        height,
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [breakpoints]);
  
  return state;
};

function getScreenInfo(width: number, breakpoints: BreakpointConfig) {
  let screenSize: ScreenSize = 'sm';
  
  if (width >= breakpoints['2xl']) {
    screenSize = '2xl';
  } else if (width >= breakpoints.xl) {
    screenSize = 'xl';
  } else if (width >= breakpoints.lg) {
    screenSize = 'lg';
  } else if (width >= breakpoints.md) {
    screenSize = 'md';
  } else {
    screenSize = 'sm';
  }
  
  return {
    screenSize,
    isMobile: width < breakpoints.md,
    isTablet: width >= breakpoints.md && width < breakpoints.lg,
    isDesktop: width >= breakpoints.lg,
  };
}
```

#### æ­¥éª¤6.1.2: åˆ›å»ºç§»åŠ¨ç«¯æ’­æ”¾å™¨æ 
åˆ›å»º `src/components/player/MobilePlayerBar.tsx`:
```typescript
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Play, Pause, SkipForward, ChevronUp } from 'lucide-react';
import { usePlayerStore } from '../../stores/playerStore';
import { SongInfo } from './SongInfo';
import { Button } from '../common/Button';
import { ProgressBar } from './ProgressBar';
import { cn } from '../../utils';

interface MobilePlayerBarProps {
  onExpandClick?: () => void;
  className?: string;
}

export const MobilePlayerBar: React.FC<MobilePlayerBarProps> = ({
  onExpandClick,
  className,
}) => {
  const {
    currentSong,
    isPlaying,
    currentTime,
    duration,
    play,
    pause,
    next,
    seek,
  } = usePlayerStore();
  
  const [isDragging, setIsDragging] = useState(false);
  
  if (!currentSong) return null;
  
  const handlePlayPause = () => {
    if (isPlaying) {
      pause();
    } else {
      play();
    }
  };
  
  return (
    <motion.div
      initial={{ y: 100 }}
      animate={{ y: 0 }}
      exit={{ y: 100 }}
      className={cn(
        'fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 shadow-lg z-50',
        className
      )}
    >
      {/* è¿›åº¦æ¡ */}
      <div className="absolute top-0 left-0 right-0 -mt-1">
        <ProgressBar
          currentTime={currentTime}
          duration={duration}
          onSeek={seek}
          onSeekStart={() => setIsDragging(true)}
          onSeekEnd={() => setIsDragging(false)}
          className="px-0"
        />
      </div>
      
      {/* ä¸»æ§åˆ¶åŒºåŸŸ */}
      <div className="flex items-center p-3 space-x-3">
        {/* æ­Œæ›²ä¿¡æ¯ */}
        <div
          className="flex-1 min-w-0 cursor-pointer"
          onClick={onExpandClick}
        >
          <SongInfo
            song={currentSong}
            size="sm"
            showControls={false}
          />
        </div>
        
        {/* æ§åˆ¶æŒ‰é’® */}
        <div className="flex items-center space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={handlePlayPause}
            className="text-gray-600 hover:text-gray-900"
          >
            {isPlaying ? (
              <Pause className="w-6 h-6" />
            ) : (
              <Play className="w-6 h-6" />
            )}
          </Button>
          
          <Button
            variant="ghost"
            size="sm"
            onClick={next}
            className="text-gray-600 hover:text-gray-900"
          >
            <SkipForward className="w-5 h-5" />
          </Button>
          
          {onExpandClick && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onExpandClick}
              className="text-gray-600 hover:text-gray-900"
            >
              <ChevronUp className="w-5 h-5" />
            </Button>
          )}
        </div>
      </div>
    </motion.div>
  );
};
```

### 6.2 è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒ

#### æ­¥éª¤6.2.1: åˆ›å»ºæ‰‹åŠ¿Hook
åˆ›å»º `src/hooks/useGestures.ts`:
```typescript
import { useRef, useEffect, useCallback } from 'react';

export interface GestureState {
  isSwipping: boolean;
  swipeDirection: 'left' | 'right' | 'up' | 'down' | null;
  swipeDistance: number;
  velocity: number;
}

export interface GestureCallbacks {
  onSwipe?: (direction: 'left' | 'right' | 'up' | 'down', distance: number, velocity: number) => void;
  onSwipeStart?: (direction: 'left' | 'right' | 'up' | 'down') => void;
  onSwipeEnd?: () => void;
  onTap?: (x: number, y: number) => void;
  onDoubleTap?: (x: number, y: number) => void;
  onLongPress?: (x: number, y: number) => void;
}

export interface GestureOptions {
  swipeThreshold?: number;
  velocityThreshold?: number;
  longPressDelay?: number;
  doubleTapDelay?: number;
  preventScroll?: boolean;
}

export const useGestures = (
  callbacks: GestureCallbacks,
  options: GestureOptions = {}
) => {
  const elementRef = useRef<HTMLElement>(null);
  const gestureStateRef = useRef<{
    startX: number;
    startY: number;
    currentX: number;
    currentY: number;
    startTime: number;
    isTracking: boolean;
    lastTap: number;
    longPressTimer?: NodeJS.Timeout;
  }>({
    startX: 0,
    startY: 0,
    currentX: 0,
    currentY: 0,
    startTime: 0,
    isTracking: false,
    lastTap: 0,
  });
  
  const {
    swipeThreshold = 50,
    velocityThreshold = 0.3,
    longPressDelay = 500,
    doubleTapDelay = 300,
    preventScroll = false,
  } = options;
  
  const getDistance = useCallback((deltaX: number, deltaY: number) => {
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  }, []);
  
  const getDirection = useCallback((deltaX: number, deltaY: number) => {
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    
    if (absX > absY) {
      return deltaX > 0 ? 'right' : 'left';
    } else {
      return deltaY > 0 ? 'down' : 'up';
    }
  }, []);
  
  const handleTouchStart = useCallback((e: TouchEvent) => {
    if (preventScroll) {
      e.preventDefault();
    }
    
    const touch = e.touches[0];
    const state = gestureStateRef.current;
    
    state.startX = touch.clientX;
    state.startY = touch.clientY;
    state.currentX = touch.clientX;
    state.currentY = touch.clientY;
    state.startTime = Date.now();
    state.isTracking = true;
    
    // æ¸…é™¤ä¹‹å‰çš„é•¿æŒ‰å®šæ—¶å™¨
    if (state.longPressTimer) {
      clearTimeout(state.longPressTimer);
    }
    
    // è®¾ç½®é•¿æŒ‰å®šæ—¶å™¨
    state.longPressTimer = setTimeout(() => {
      if (state.isTracking) {
        const distance = getDistance(
          state.currentX - state.startX,
          state.currentY - state.startY
        );
        
        // å¦‚æœæ²¡æœ‰ç§»åŠ¨å¤ªå¤šï¼Œè§¦å‘é•¿æŒ‰
        if (distance < swipeThreshold / 2) {
          callbacks.onLongPress?.(state.startX, state.startY);
        }
      }
    }, longPressDelay);
  }, [callbacks, preventScroll, swipeThreshold, longPressDelay, getDistance]);
  
  const handleTouchMove = useCallback((e: TouchEvent) => {
    if (preventScroll) {
      e.preventDefault();
    }
    
    const touch = e.touches[0];
    const state = gestureStateRef.current;
    
    if (!state.isTracking) return;
    
    state.currentX = touch.clientX;
    state.currentY = touch.clientY;
    
    const deltaX = state.currentX - state.startX;
    const deltaY = state.currentY - state.startY;
    const distance = getDistance(deltaX, deltaY);
    
    // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œå–æ¶ˆé•¿æŒ‰
    if (distance > swipeThreshold / 2 && state.longPressTimer) {
      clearTimeout(state.longPressTimer);
      state.longPressTimer = undefined;
    }
    
    // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡æ»‘åŠ¨é˜ˆå€¼ï¼Œå¼€å§‹æ»‘åŠ¨
    if (distance > swipeThreshold) {
      const direction = getDirection(deltaX, deltaY);
      callbacks.onSwipeStart?.(direction);
    }
  }, [callbacks, preventScroll, swipeThreshold, getDistance, getDirection]);
  
  const handleTouchEnd = useCallback((e: TouchEvent) => {
    if (preventScroll) {
      e.preventDefault();
    }
    
    const state = gestureStateRef.current;
    
    if (!state.isTracking) return;
    
    const endTime = Date.now();
    const deltaTime = endTime - state.startTime;
    const deltaX = state.currentX - state.startX;
    const deltaY = state.currentY - state.startY;
    const distance = getDistance(deltaX, deltaY);
    const velocity = distance / deltaTime;
    
    // æ¸…é™¤é•¿æŒ‰å®šæ—¶å™¨
    if (state.longPressTimer) {
      clearTimeout(state.longPressTimer);
      state.longPressTimer = undefined;
    }
    
    state.isTracking = false;
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºæ»‘åŠ¨
    if (distance > swipeThreshold || velocity > velocityThreshold) {
      const direction = getDirection(deltaX, deltaY);
      callbacks.onSwipe?.(direction, distance, velocity);
      callbacks.onSwipeEnd?.();
    } else {
      // åˆ¤æ–­æ˜¯å¦ä¸ºç‚¹å‡»æˆ–åŒå‡»
      const now = Date.now();
      const timeSinceLastTap = now - state.lastTap;
      
      if (timeSinceLastTap < doubleTapDelay) {
        // åŒå‡»
        callbacks.onDoubleTap?.(state.startX, state.startY);
        state.lastTap = 0; // é‡ç½®ä»¥é¿å…ä¸‰å‡»
      } else {
        // å•å‡»
        callbacks.onTap?.(state.startX, state.startY);
        state.lastTap = now;
      }
    }
  }, [
    callbacks,
    preventScroll,
    swipeThreshold,
    velocityThreshold,
    doubleTapDelay,
    getDistance,
    getDirection,
  ]);
  
  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;
    
    element.addEventListener('touchstart', handleTouchStart, { passive: !preventScroll });
    element.addEventListener('touchmove', handleTouchMove, { passive: !preventScroll });
    element.addEventListener('touchend', handleTouchEnd, { passive: !preventScroll });
    
    return () => {
      element.removeEventListener('touchstart', handleTouchStart);
      element.removeEventListener('touchmove', handleTouchMove);
      element.removeEventListener('touchend', handleTouchEnd);
      
      // æ¸…ç†å®šæ—¶å™¨
      const state = gestureStateRef.current;
      if (state.longPressTimer) {
        clearTimeout(state.longPressTimer);
      }
    };
  }, [handleTouchStart, handleTouchMove, handleTouchEnd, preventScroll]);
  
  return elementRef;
};
```

### 6.3 PWAåŠŸèƒ½å®ç°

#### æ­¥éª¤6.3.1: åˆ›å»ºService Worker
åˆ›å»º `public/sw.js`:
```javascript
const CACHE_NAME = 'netease-music-player-v1.0.0';
const STATIC_CACHE = 'static-cache-v1';
const DYNAMIC_CACHE = 'dynamic-cache-v1';
const AUDIO_CACHE = 'audio-cache-v1';
const IMAGE_CACHE = 'image-cache-v1';

// éœ€è¦ç¼“å­˜çš„é™æ€èµ„æº
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json',
  '/favicon.ico',
];

// å®‰è£…äº‹ä»¶
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        return self.skipWaiting();
      })
  );
});

// æ¿€æ´»äº‹ä»¶
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== STATIC_CACHE && 
                cacheName !== DYNAMIC_CACHE && 
                cacheName !== AUDIO_CACHE &&
                cacheName !== IMAGE_CACHE) {
              console.log('Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        return self.clients.claim();
      })
  );
});

// è·å–äº‹ä»¶
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // è·³è¿‡é GET è¯·æ±‚
  if (request.method !== 'GET') {
    return;
  }
  
  // éŸ³é¢‘æ–‡ä»¶ç¼“å­˜ç­–ç•¥
  if (request.url.includes('audio') || 
      request.url.includes('.mp3') || 
      request.url.includes('.flac') ||
      request.url.includes('.wav')) {
    event.respondWith(handleAudioRequest(request));
    return;
  }
  
  // å›¾ç‰‡æ–‡ä»¶ç¼“å­˜ç­–ç•¥
  if (request.url.includes('image') || 
      request.url.includes('.jpg') || 
      request.url.includes('.png') ||
      request.url.includes('.webp') ||
      request.url.includes('.gif')) {
    event.respondWith(handleImageRequest(request));
    return;
  }
  
  // é™æ€èµ„æºç¼“å­˜ç­–ç•¥
  if (STATIC_ASSETS.some(asset => request.url.includes(asset))) {
    event.respondWith(handleStaticRequest(request));
    return;
  }
  
  // APIè¯·æ±‚ç¼“å­˜ç­–ç•¥
  if (request.url.includes('/api/')) {
    event.respondWith(handleAPIRequest(request));
    return;
  }
  
  // é»˜è®¤ç½‘ç»œä¼˜å…ˆç­–ç•¥
  event.respondWith(handleNetworkFirst(request));
});

// å¤„ç†éŸ³é¢‘è¯·æ±‚ - ç¼“å­˜ä¼˜å…ˆ
async function handleAudioRequest(request) {
  try {
    const cache = await caches.open(AUDIO_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      console.log('Audio cache hit:', request.url);
      return cachedResponse;
    }
    
    console.log('Audio cache miss, fetching:', request.url);
    const response = await fetch(request);
    
    if (response.ok) {
      // æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ¶
      const cacheSize = await getCacheSize(AUDIO_CACHE);
      const maxSize = 100 * 1024 * 1024; // 100MB
      
      if (cacheSize < maxSize) {
        cache.put(request, response.clone());
      } else {
        // æ¸…ç†æœ€æ—§çš„ç¼“å­˜
        await cleanupOldCache(AUDIO_CACHE, 0.7); // æ¸…ç†30%çš„ç¼“å­˜
        cache.put(request, response.clone());
      }
    }
    
    return response;
  } catch (error) {
    console.error('Audio request failed:', error);
    return new Response('Audio not available offline', { 
      status: 503,
      statusText: 'Service Unavailable' 
    });
  }
}

// å¤„ç†å›¾ç‰‡è¯·æ±‚ - ç¼“å­˜ä¼˜å…ˆ
async function handleImageRequest(request) {
  try {
    const cache = await caches.open(IMAGE_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    const response = await fetch(request);
    
    if (response.ok) {
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.error('Image request failed:', error);
    // è¿”å›é»˜è®¤å›¾ç‰‡
    return new Response('', { status: 404 });
  }
}

// å¤„ç†é™æ€èµ„æº - ç¼“å­˜ä¼˜å…ˆ
async function handleStaticRequest(request) {
  try {
    const cache = await caches.open(STATIC_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    const response = await fetch(request);
    
    if (response.ok) {
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.error('Static request failed:', error);
    return cache.match('/index.html'); // è¿”å›ç¦»çº¿é¡µé¢
  }
}

// å¤„ç†APIè¯·æ±‚ - ç½‘ç»œä¼˜å…ˆï¼Œç¼“å­˜å¤‡ç”¨
async function handleAPIRequest(request) {
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.log('API request failed, trying cache:', request.url);
    const cache = await caches.open(DYNAMIC_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    return new Response(JSON.stringify({ 
      error: 'Offline',
      message: 'No network connection and no cached data available' 
    }), {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// ç½‘ç»œä¼˜å…ˆç­–ç•¥
async function handleNetworkFirst(request) {
  try {
    const response = await fetch(request);
    return response;
  } catch (error) {
    const cache = await caches.open(DYNAMIC_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    return new Response('Offline', { status: 503 });
  }
}

// è·å–ç¼“å­˜å¤§å°
async function getCacheSize(cacheName) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  let totalSize = 0;
  
  for (const key of keys) {
    const response = await cache.match(key);
    if (response) {
      const blob = await response.blob();
      totalSize += blob.size;
    }
  }
  
  return totalSize;
}

// æ¸…ç†æ—§ç¼“å­˜
async function cleanupOldCache(cacheName, ratio = 0.3) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  const deleteCount = Math.floor(keys.length * ratio);
  
  // åˆ é™¤æœ€æ—§çš„ç¼“å­˜é¡¹ï¼ˆè¿™é‡Œç®€å•æŒ‰ç´¢å¼•åˆ é™¤ï¼Œå®é™…åº”è¯¥æŒ‰æ—¶é—´æˆ³ï¼‰
  for (let i = 0; i < deleteCount; i++) {
    await cache.delete(keys[i]);
  }
}

// ç›‘å¬æ¶ˆæ¯äº‹ä»¶
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'CACHE_AUDIO') {
    const { url } = event.data;
    caches.open(AUDIO_CACHE)
      .then(cache => cache.add(url))
      .catch(error => console.error('Failed to cache audio:', error));
  }
});
```

### 6.4 éªŒæ”¶æ ‡å‡†

#### é˜¶æ®µ6å®Œæˆæ£€æŸ¥æ¸…å•ï¼š
- [ ] âœ… ç§»åŠ¨ç«¯å¸ƒå±€é€‚é…å®Œæ•´
- [ ] âœ… è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒæ­£å¸¸
- [ ] âœ… PWAåŠŸèƒ½å®ç°å®Œæ•´
- [ ] âœ… ç¦»çº¿ç¼“å­˜ç­–ç•¥æœ‰æ•ˆ
- [ ] âœ… ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–å®Œæˆ
- [ ] âœ… è·¨è®¾å¤‡å…¼å®¹æ€§æµ‹è¯•é€šè¿‡

---

## ğŸ§ª é˜¶æ®µ7: æµ‹è¯•ä¸ä¼˜åŒ– (ç¬¬14-15å‘¨)

### 7.1 å•å…ƒæµ‹è¯•

#### æ­¥éª¤7.1.1: é…ç½®æµ‹è¯•ç¯å¢ƒ
```bash
# å®‰è£…æµ‹è¯•ä¾èµ–
npm install -D @testing-library/react @testing-library/jest-dom @testing-library/user-event
npm install -D vitest jsdom @vitest/ui
npm install -D @types/jest
```

åˆ›å»º `vitest.config.ts`:
```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
  },
});
```

#### æ­¥éª¤7.1.2: åˆ›å»ºæµ‹è¯•ç”¨ä¾‹
åˆ›å»º `src/services/audio/__tests__/AudioService.test.ts`:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { AudioService } from '../AudioService';
import { Song, MusicSource, AudioQuality } from '../../../types';

// Mock AudioContext
Object.defineProperty(window, 'AudioContext', {
  writable: true,
  value: vi.fn().mockImplementation(() => ({
    createGain: vi.fn(() => ({ connect: vi.fn() })),
    createAnalyser: vi.fn(() => ({ connect: vi.fn() })),
    createMediaElementSource: vi.fn(() => ({ connect: vi.fn() })),
    destination: {},
    resume: vi.fn(),
  })),
});

const mockSong: Song = {
  id: 'test-song-1',
  title: 'Test Song',
  artist: 'Test Artist',
  album: 'Test Album',
  duration: 180,
  coverUrl: 'https://example.com/cover.jpg',
  audioUrl: 'https://example.com/audio.mp3',
  source: MusicSource.LOCAL,
  quality: AudioQuality.STANDARD
};

describe('AudioService', () => {
  let audioService: AudioService;
  
  beforeEach(() => {
    audioService = new AudioService();
  });
  
  it('should initialize properly', () => {
    expect(audioService).toBeDefined();
  });
  
  it('should add song to queue', () => {
    audioService.addToQueue(mockSong);
    const queue = audioService.getQueue();
    
    expect(queue).toHaveLength(1);
    expect(queue[0]).toEqual(mockSong);
  });
  
  it('should remove song from queue', () => {
    audioService.addToQueue(mockSong);
    audioService.removeFromQueue(0);
    
    expect(audioService.getQueue()).toHaveLength(0);
  });
  
  it('should set and get volume', () => {
    audioService.setVolume(0.5);
    // Note: å®é™…æµ‹è¯•ä¸­éœ€è¦mockéŸ³é¢‘å¼•æ“çš„çŠ¶æ€
  });
});
```

### 7.2 é›†æˆæµ‹è¯•

#### æ­¥éª¤7.2.1: ç»„ä»¶é›†æˆæµ‹è¯•
åˆ›å»º `src/components/player/__tests__/PlayControls.test.tsx`:
```typescript
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { PlayControls } from '../PlayControls';
import { PlayMode } from '../../../types';

describe('PlayControls', () => {
  const defaultProps = {
    isPlaying: false,
    playMode: PlayMode.SEQUENCE,
    onPlay: vi.fn(),
    onPause: vi.fn(),
    onNext: vi.fn(),
    onPrevious: vi.fn(),
    onShuffle: vi.fn(),
    onPlayModeChange: vi.fn(),
  };
  
  it('should render play button when not playing', () => {
    render(<PlayControls {...defaultProps} />);
    
    const playButton = screen.getByTitle('æ’­æ”¾');
    expect(playButton).toBeInTheDocument();
  });
  
  it('should render pause button when playing', () => {
    render(<PlayControls {...defaultProps} isPlaying={true} />);
    
    const pauseButton = screen.getByTitle('æš‚åœ');
    expect(pauseButton).toBeInTheDocument();
  });
  
  it('should call onPlay when play button is clicked', () => {
    const onPlay = vi.fn();
    render(<PlayControls {...defaultProps} onPlay={onPlay} />);
    
    const playButton = screen.getByTitle('æ’­æ”¾');
    fireEvent.click(playButton);
    
    expect(onPlay).toHaveBeenCalledTimes(1);
  });
  
  it('should call onNext when next button is clicked', () => {
    const onNext = vi.fn();
    render(<PlayControls {...defaultProps} onNext={onNext} />);
    
    const nextButton = screen.getByTitle('ä¸‹ä¸€é¦–');
    fireEvent.click(nextButton);
    
    expect(onNext).toHaveBeenCalledTimes(1);
  });
});
```

### 7.3 æ€§èƒ½æµ‹è¯•

#### æ­¥éª¤7.3.1: æ€§èƒ½ç›‘æ§å·¥å…·
åˆ›å»º `src/utils/performance.ts`:
```typescript
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();
  private observers: PerformanceObserver[] = [];
  
  constructor() {
    this.setupObservers();
  }
  
  private setupObservers() {
    // ç›‘æ§å¯¼èˆªæ€§èƒ½
    if ('PerformanceObserver' in window) {
      const navObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          this.recordMetric('navigation', entry.duration);
        });
      });
      
      navObserver.observe({ entryTypes: ['navigation'] });
      this.observers.push(navObserver);
      
      // ç›‘æ§èµ„æºåŠ è½½æ€§èƒ½
      const resourceObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.name.includes('.mp3') || entry.name.includes('audio')) {
            this.recordMetric('audio-load', entry.duration);
          } else if (entry.name.includes('.jpg') || entry.name.includes('.png')) {
            this.recordMetric('image-load', entry.duration);
          }
        });
      });
      
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);
    }
  }
  
  // è®°å½•è‡ªå®šä¹‰æ€§èƒ½æŒ‡æ ‡
  recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    
    this.metrics.get(name)!.push(value);
    
    // ä¿æŒæœ€è¿‘100ä¸ªè®°å½•
    const values = this.metrics.get(name)!;
    if (values.length > 100) {
      values.shift();
    }
  }
  
  // æµ‹é‡å‡½æ•°æ‰§è¡Œæ—¶é—´
  measure<T>(name: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    this.recordMetric(name, end - start);
    return result;
  }
  
  // æµ‹é‡å¼‚æ­¥å‡½æ•°æ‰§è¡Œæ—¶é—´
  async measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    
    this.recordMetric(name, end - start);
    return result;
  }
  
  // è·å–æ€§èƒ½ç»Ÿè®¡
  getStats(name: string) {
    const values = this.metrics.get(name) || [];
    
    if (values.length === 0) {
      return null;
    }
    
    const sorted = [...values].sort((a, b) => a - b);
    const sum = values.reduce((a, b) => a + b, 0);
    
    return {
      count: values.length,
      average: sum / values.length,
      median: sorted[Math.floor(sorted.length / 2)],
      min: Math.min(...values),
      max: Math.max(...values),
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }
  
  // è·å–æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡
  getAllStats() {
    const stats: Record<string, any> = {};
    
    for (const [name] of this.metrics) {
      stats[name] = this.getStats(name);
    }
    
    return stats;
  }
  
  // æ¸…ç†èµ„æº
  dispose() {
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    this.metrics.clear();
  }
}

// å•ä¾‹æ€§èƒ½ç›‘æ§å™¨
export const performanceMonitor = new PerformanceMonitor();

// æ€§èƒ½è£…é¥°å™¨
export function measurePerformance(name: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
      return performanceMonitor.measure(`${target.constructor.name}.${propertyName}`, 
        () => method.apply(this, args)
      );
    };
    
    return descriptor;
  };
}
```

### 7.4 éƒ¨ç½²ä¸å‘å¸ƒ

#### æ­¥éª¤7.4.1: æ„å»ºä¼˜åŒ–é…ç½®
æ›´æ–° `vite.config.ts`:
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\./,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              cacheableResponse: {
                statuses: [0, 200]
              }
            }
          },
          {
            urlPattern: /\.(mp3|flac|wav)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'audio-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 7 * 24 * 60 * 60 // 7 days
              }
            }
          }
        ]
      },
      manifest: {
        name: 'ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨',
        short_name: 'éŸ³ä¹æ’­æ”¾å™¨',
        description: 'ä¸€ä¸ªä»¿ç½‘æ˜“äº‘éŸ³ä¹çš„åœ¨çº¿æ’­æ”¾å™¨',
        theme_color: '#C62D42',
        background_color: '#ffffff',
        display: 'standalone',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      }
    })
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          audio: ['./src/services/audio'],
          ui: ['lucide-react', 'framer-motion']
        }
      }
    },
    sourcemap: true,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  },
  define: {
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version)
  }
});
```

### 7.5 éªŒæ”¶æ ‡å‡†

#### é˜¶æ®µ7å®Œæˆæ£€æŸ¥æ¸…å•ï¼š
- [ ] âœ… å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] âœ… é›†æˆæµ‹è¯•é€šè¿‡
- [ ] âœ… æ€§èƒ½æŒ‡æ ‡ç¬¦åˆè¦æ±‚
- [ ] âœ… è·¨æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•é€šè¿‡
- [ ] âœ… ç§»åŠ¨ç«¯æµ‹è¯•é€šè¿‡
- [ ] âœ… PWAåŠŸèƒ½æµ‹è¯•é€šè¿‡
- [ ] âœ… æ„å»ºä¼˜åŒ–å®Œæˆ

---

## ğŸš€ é˜¶æ®µ8: éƒ¨ç½²ä¸å‘å¸ƒ (ç¬¬16å‘¨)

### 8.1 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

#### æ­¥éª¤8.1.1: åˆ›å»ºéƒ¨ç½²è„šæœ¬
åˆ›å»º `scripts/deploy.sh`:
```bash
#!/bin/bash

# ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨éƒ¨ç½²è„šæœ¬

set -e

echo "ğŸš€ Starting deployment process..."

# æ£€æŸ¥ç¯å¢ƒ
if [ -z "$NODE_ENV" ]; then
  export NODE_ENV=production
fi

echo "ğŸ“¦ Building application..."
npm run build

echo "ğŸ” Running post-build checks..."
npm run lint
npm run test:coverage

echo "ğŸ“Š Analyzing bundle size..."
npm run analyze

echo "ğŸŒ Deploying to production..."

# éƒ¨ç½²åˆ°Vercel (ç¤ºä¾‹)
if [ "$DEPLOY_TARGET" = "vercel" ]; then
  vercel --prod
fi

# éƒ¨ç½²åˆ°Netlify (ç¤ºä¾‹)
if [ "$DEPLOY_TARGET" = "netlify" ]; then
  netlify deploy --prod --dir=dist
fi

echo "âœ… Deployment completed successfully!"
```

#### æ­¥éª¤8.1.2: ç¯å¢ƒé…ç½®
åˆ›å»º `.env.production`:
```env
VITE_APP_TITLE=ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨
VITE_API_BASE_URL=https://api.example.com
VITE_SENTRY_DSN=your_sentry_dsn
VITE_ANALYTICS_ID=your_analytics_id
```

### 8.2 ç›‘æ§ä¸æ—¥å¿—

#### æ­¥éª¤8.2.1: é”™è¯¯ç›‘æ§
```bash
npm install @sentry/react @sentry/tracing
```

åˆ›å»º `src/utils/monitoring.ts`:
```typescript
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/tracing';

export function initializeMonitoring() {
  if (import.meta.env.PROD && import.meta.env.VITE_SENTRY_DSN) {
    Sentry.init({
      dsn: import.meta.env.VITE_SENTRY_DSN,
      environment: import.meta.env.MODE,
      integrations: [
        new BrowserTracing({
          tracingOrigins: ['localhost', /^\//],
        }),
      ],
      tracesSampleRate: 0.1,
      beforeSend(event, hint) {
        // è¿‡æ»¤æ‰å¼€å‘ç¯å¢ƒçš„é”™è¯¯
        if (import.meta.env.DEV) {
          return null;
        }
        return event;
      },
    });
  }
}

export function captureException(error: Error, context?: any) {
  if (import.meta.env.PROD) {
    Sentry.captureException(error, context);
  } else {
    console.error('Error:', error, context);
  }
}
```

### 8.3 æœ€ç»ˆéªŒæ”¶

#### å®Œæ•´é¡¹ç›®éªŒæ”¶æ¸…å•ï¼š

##### åŠŸèƒ½å®Œæ•´æ€§ âœ…
- [ ] âœ… éŸ³ä¹æ’­æ”¾ã€æš‚åœã€åœæ­¢
- [ ] âœ… æ’­æ”¾é˜Ÿåˆ—ç®¡ç†
- [ ] âœ… éŸ³é‡æ§åˆ¶
- [ ] âœ… æ’­æ”¾æ¨¡å¼åˆ‡æ¢
- [ ] âœ… è¿›åº¦æ§åˆ¶
- [ ] âœ… æ­Œæ›²æœç´¢
- [ ] âœ… æ­Œè¯æ˜¾ç¤º
- [ ] âœ… ç”¨æˆ·æ”¶è—
- [ ] âœ… æ’­æ”¾å†å²
- [ ] âœ… éŸ³é¢‘å¯è§†åŒ–

##### æŠ€æœ¯è¦æ±‚ âœ…
- [ ] âœ… React 18 + TypeScript
- [ ] âœ… å“åº”å¼è®¾è®¡
- [ ] âœ… PWAæ”¯æŒ
- [ ] âœ… ç¦»çº¿åŠŸèƒ½
- [ ] âœ… æ€§èƒ½ä¼˜åŒ–
- [ ] âœ… é”™è¯¯å¤„ç†
- [ ] âœ… æµ‹è¯•è¦†ç›–

##### ç”¨æˆ·ä½“éªŒ âœ…
- [ ] âœ… ç•Œé¢ç¾è§‚
- [ ] âœ… äº¤äº’æµç•…
- [ ] âœ… åŠ è½½è¿…é€Ÿ
- [ ] âœ… ç§»åŠ¨ç«¯é€‚é…
- [ ] âœ… è§¦æ‘¸æ‰‹åŠ¿
- [ ] âœ… æ— éšœç¢æ”¯æŒ

---

## ğŸ“‹ æ€»ç»“

è¿™ä»½è¯¦ç»†çš„å¼€å‘å®æ–½æ–¹æ¡ˆæ¶µç›–äº†ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨çš„å®Œæ•´å¼€å‘æµç¨‹ï¼š

### ğŸ¯ æ ¸å¿ƒæˆæœ
1. **å®Œæ•´çš„éŸ³é¢‘æ’­æ”¾ç³»ç»Ÿ** - æ”¯æŒå¤šç§éŸ³é¢‘æ ¼å¼å’Œæ’­æ”¾æ¨¡å¼
2. **ç°ä»£åŒ–çš„ç”¨æˆ·ç•Œé¢** - å“åº”å¼è®¾è®¡ï¼Œç§»åŠ¨ç«¯ä¼˜åŒ–
3. **é«˜æ€§èƒ½ä¼˜åŒ–** - ä»£ç åˆ†å‰²ã€ç¼“å­˜ç­–ç•¥ã€è™šæ‹Ÿæ»šåŠ¨
4. **PWAåº”ç”¨** - ç¦»çº¿æ”¯æŒã€å®‰è£…åˆ°æ¡Œé¢
5. **å®Œå–„çš„æµ‹è¯•è¦†ç›–** - å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•

### ğŸ›  æŠ€æœ¯äº®ç‚¹
- **Web Audio API** ä¸“ä¸šéŸ³é¢‘å¤„ç†
- **Zustand** è½»é‡çº§çŠ¶æ€ç®¡ç†
- **IndexedDB** æœ¬åœ°æ•°æ®æŒä¹…åŒ–
- **Service Worker** ç¦»çº¿ç¼“å­˜ç­–ç•¥
- **Framer Motion** æµç•…åŠ¨ç”»æ•ˆæœ

### ğŸ“ˆ å¼€å‘è¿›åº¦
- **æ€»è®¡16å‘¨** å®Œæ•´å¼€å‘å‘¨æœŸ
- **8ä¸ªé˜¶æ®µ** å¾ªåºæ¸è¿›å®æ–½
- **è¯¦ç»†éªŒæ”¶æ ‡å‡†** ç¡®ä¿è´¨é‡äº¤ä»˜

è¿™ä¸ªæ–¹æ¡ˆæä¾›äº†ä»é¡¹ç›®åˆå§‹åŒ–åˆ°æœ€ç»ˆéƒ¨ç½²çš„å®Œæ•´æŒ‡å¯¼ï¼Œæ¯ä¸ªæ­¥éª¤éƒ½æœ‰å…·ä½“çš„ä»£ç å®ç°å’ŒéªŒæ”¶æ ‡å‡†ï¼Œç¡®ä¿å¼€å‘å›¢é˜Ÿèƒ½å¤Ÿé«˜æ•ˆã€é«˜è´¨é‡åœ°å®Œæˆé¡¹ç›®äº¤ä»˜ã€‚