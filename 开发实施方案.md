# 网易云音乐播放器 - 开发实施方案

## 项目概览

基于详细技术设计，本开发方案将分8个阶段、16周时间完成网易云音乐播放器的完整开发。每个阶段都有明确的目标、具体的实施步骤和验收标准。

---

## 🚀 阶段1: 项目基础设施搭建 (第1-2周)

### 1.1 环境准备与项目初始化

#### 步骤1.1.1: 开发环境配置
```bash
# 1. 确保Node.js版本 >= 16
node --version

# 2. 创建项目目录
mkdir netease-music-player
cd netease-music-player

# 3. 初始化Vite项目
npm create vite@latest . -- --template react-ts

# 4. 安装基础依赖
npm install

# 5. 安装必要的开发依赖
npm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser
npm install -D prettier eslint-config-prettier eslint-plugin-prettier
npm install -D @types/node
npm install -D husky lint-staged
```

#### 步骤1.1.2: 项目结构设置
```bash
# 创建标准目录结构
mkdir -p src/{components,pages,hooks,services,stores,types,utils,assets}
mkdir -p src/components/{common,player,search,playlist}
mkdir -p src/services/{audio,api,cache,storage}
mkdir -p public/{icons,images}
```

**项目目录结构：**
```
src/
├── components/           # 组件目录
│   ├── common/          # 通用组件
│   ├── player/          # 播放器组件
│   ├── search/          # 搜索组件
│   └── playlist/        # 播放列表组件
├── pages/               # 页面组件
├── hooks/               # 自定义Hook
├── services/            # 服务层
│   ├── audio/           # 音频服务
│   ├── api/             # API服务
│   ├── cache/           # 缓存服务
│   └── storage/         # 存储服务
├── stores/              # 状态管理
├── types/               # TypeScript类型定义
├── utils/               # 工具函数
└── assets/              # 静态资源
```

### 1.2 开发工具配置

#### 步骤1.2.1: ESLint配置
创建 `.eslintrc.js`:
```javascript
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
    'prettier'
  ],
  ignorePatterns: ['dist', '.eslintrc.js'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    'prefer-const': 'error',
  },
}
```

#### 步骤1.2.2: Prettier配置
创建 `.prettierrc`:
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
```

#### 步骤1.2.3: Git配置
```bash
# 初始化Git
git init

# 创建.gitignore
cat > .gitignore << EOF
# Dependencies
node_modules/

# Production builds
dist/
build/

# Environment variables
.env
.env.local
.env.production

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Cache
.cache/
.parcel-cache/
EOF

# 配置Husky和lint-staged
npx husky-init
npm pkg set scripts.prepare="husky install"
npm run prepare

# 添加pre-commit hook
npx husky add .husky/pre-commit "npx lint-staged"

# 配置lint-staged
npm pkg set lint-staged."{\"*.{ts,tsx}\":\"eslint --fix\",\"*.{ts,tsx,css,md}\":\"prettier --write\"}"
```

### 1.3 基础依赖安装

#### 步骤1.3.1: 核心依赖安装
```bash
# 状态管理
npm install zustand

# 路由
npm install react-router-dom

# 样式框架
npm install tailwindcss postcss autoprefixer
npm install -D @tailwindcss/typography

# UI组件库基础
npm install lucide-react
npm install framer-motion

# 工具库
npm install clsx
npm install date-fns
```

#### 步骤1.3.2: Tailwind CSS配置
```bash
# 初始化Tailwind
npx tailwindcss init -p

# 配置tailwind.config.js
cat > tailwind.config.js << 'EOF'
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#fef2f2',
          500: '#ef4444',
          600: '#dc2626',
          700: '#b91c1c',
          900: '#7f1d1d',
        },
        netease: '#C62D42',
      },
      fontFamily: {
        sans: ['PingFang SC', 'Microsoft YaHei', 'sans-serif'],
      },
    },
  },
  plugins: [],
  darkMode: 'class',
}
EOF
```

#### 步骤1.3.3: 配置CSS入口文件
更新 `src/index.css`:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    box-sizing: border-box;
  }
  
  html {
    font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
  }
  
  body {
    margin: 0;
    padding: 0;
    background-color: #f5f5f7;
  }
}

@layer components {
  .btn-primary {
    @apply bg-netease text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors;
  }
  
  .card {
    @apply bg-white rounded-lg shadow-sm border border-gray-100;
  }
}
```

### 1.4 基础类型定义

#### 步骤1.4.1: 创建核心类型定义
创建 `src/types/index.ts`:
```typescript
// 音乐源枚举
export enum MusicSource {
  QQ_MUSIC = 'qq',
  KUGOU = 'kugou',
  MIGU = 'migu',
  LOCAL = 'local'
}

// 音质枚举
export enum AudioQuality {
  LOW = '128k',
  STANDARD = '192k',
  HIGH = '320k',
  LOSSLESS = 'flac'
}

// 播放模式枚举
export enum PlayMode {
  SEQUENCE = 'sequence',
  RANDOM = 'random',
  SINGLE = 'single',
  LIST_LOOP = 'list_loop'
}

// 歌曲接口
export interface Song {
  id: string;
  title: string;
  artist: string;
  album: string;
  duration: number;
  coverUrl: string;
  audioUrl?: string;
  source: MusicSource;
  quality: AudioQuality;
  lyricId?: string;
}

// 专辑接口
export interface Album {
  id: string;
  title: string;
  artist: string;
  coverUrl: string;
  releaseDate: Date;
  songs: Song[];
  source: MusicSource;
}

// 艺术家接口
export interface Artist {
  id: string;
  name: string;
  avatarUrl: string;
  description: string;
  albums: Album[];
  topSongs: Song[];
  source: MusicSource;
}

// 播放列表接口
export interface Playlist {
  id: string;
  title: string;
  description: string;
  coverUrl: string;
  creator: string;
  songs: Song[];
  isPublic: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// 歌词接口
export interface LyricLine {
  time: number;
  text: string;
  translation?: string;
}

export interface Lyrics {
  songId: string;
  lines: LyricLine[];
  offset: number;
}

// 搜索结果接口
export interface SearchResult {
  songs: Song[];
  albums: Album[];
  artists: Artist[];
  playlists: Playlist[];
  total: number;
  page: number;
  pageSize: number;
}
```

### 1.5 基础工具函数

#### 步骤1.5.1: 创建工具函数
创建 `src/utils/index.ts`:
```typescript
/**
 * 格式化时间 (秒 -> mm:ss)
 */
export function formatTime(seconds: number): string {
  if (!seconds || seconds < 0) return '00:00';
  
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * 格式化文件大小
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B';
  
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * 防抖函数
 */
export function debounce<T extends (...args: any[]) => void>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

/**
 * 节流函数
 */
export function throttle<T extends (...args: any[]) => void>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

/**
 * 生成唯一ID
 */
export function generateId(): string {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

/**
 * 深度合并对象
 */
export function deepMerge<T>(target: T, source: Partial<T>): T {
  const result = { ...target };
  
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object') {
      result[key] = deepMerge(result[key], source[key]);
    } else {
      result[key] = source[key] as T[Extract<keyof T, string>];
    }
  }
  
  return result;
}

/**
 * 类名合并工具 (类似clsx)
 */
export function cn(...classes: (string | undefined | null | false)[]): string {
  return classes.filter(Boolean).join(' ');
}
```

### 1.6 验收标准

#### 阶段1完成检查清单：
- [ ] ✅ 项目成功初始化，可以运行 `npm run dev`
- [ ] ✅ ESLint和Prettier配置正确，代码格式化正常
- [ ] ✅ Git配置完成，pre-commit hook工作正常
- [ ] ✅ Tailwind CSS配置正确，样式可以正常使用
- [ ] ✅ 基础类型定义完整，符合设计规范
- [ ] ✅ 工具函数测试通过
- [ ] ✅ 项目目录结构规范，符合约定

---

## 🎵 阶段2: 核心音频引擎开发 (第3-4周)

### 2.1 音频引擎核心架构

#### 步骤2.1.1: 创建音频引擎接口
创建 `src/services/audio/types.ts`:
```typescript
// 播放器状态类型
export type PlaybackState = 'idle' | 'loading' | 'playing' | 'paused' | 'ended' | 'error';

// 音频事件类型
export type AudioEvent = 
  | 'loadstart' | 'loadeddata' | 'canplay' | 'canplaythrough'
  | 'play' | 'pause' | 'ended' | 'timeupdate' | 'progress'
  | 'volumechange' | 'error' | 'stalled';

// 音频引擎接口
export interface AudioEngine {
  // 播放控制
  play(): Promise<void>;
  pause(): void;
  stop(): void;
  seek(position: number): void;
  
  // 音量和音效
  setVolume(volume: number): void;
  setMuted(muted: boolean): void;
  setPlaybackRate(rate: number): void;
  
  // 音频信息
  getCurrentTime(): number;
  getDuration(): number;
  getBuffered(): TimeRanges;
  
  // 状态查询
  getState(): PlaybackState;
  
  // 事件监听
  addEventListener(event: AudioEvent, handler: Function): void;
  removeEventListener(event: AudioEvent, handler: Function): void;
  
  // 资源管理
  loadSong(song: Song): Promise<void>;
  unload(): void;
  
  // 音频分析
  getFrequencyData(): Uint8Array;
}
```

#### 步骤2.1.2: 实现Web Audio音频引擎
创建 `src/services/audio/WebAudioEngine.ts`:
```typescript
import { AudioEngine, PlaybackState, AudioEvent } from './types';
import { Song } from '../../types';

export class WebAudioEngine implements AudioEngine {
  private audio: HTMLAudioElement;
  private audioContext: AudioContext | null = null;
  private gainNode: GainNode | null = null;
  private analyser: AnalyserNode | null = null;
  private source: MediaElementAudioSourceNode | null = null;
  
  private state: PlaybackState = 'idle';
  private eventListeners = new Map<AudioEvent, Set<Function>>();
  private currentSong: Song | null = null;
  
  constructor() {
    this.audio = new Audio();
    this.setupAudioElement();
    this.initializeAudioContext();
  }
  
  private setupAudioElement(): void {
    this.audio.crossOrigin = 'anonymous';
    this.audio.preload = 'metadata';
    
    // 绑定音频事件
    this.audio.addEventListener('loadstart', () => this.emitEvent('loadstart'));
    this.audio.addEventListener('loadeddata', () => this.emitEvent('loadeddata'));
    this.audio.addEventListener('canplay', () => this.emitEvent('canplay'));
    this.audio.addEventListener('canplaythrough', () => this.emitEvent('canplaythrough'));
    this.audio.addEventListener('play', () => {
      this.state = 'playing';
      this.emitEvent('play');
    });
    this.audio.addEventListener('pause', () => {
      this.state = 'paused';
      this.emitEvent('pause');
    });
    this.audio.addEventListener('ended', () => {
      this.state = 'ended';
      this.emitEvent('ended');
    });
    this.audio.addEventListener('timeupdate', () => this.emitEvent('timeupdate'));
    this.audio.addEventListener('progress', () => this.emitEvent('progress'));
    this.audio.addEventListener('volumechange', () => this.emitEvent('volumechange'));
    this.audio.addEventListener('error', () => {
      this.state = 'error';
      this.emitEvent('error');
    });
    this.audio.addEventListener('stalled', () => this.emitEvent('stalled'));
  }
  
  private async initializeAudioContext(): Promise<void> {
    try {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      this.gainNode = this.audioContext.createGain();
      this.analyser = this.audioContext.createAnalyser();
      
      // 配置分析器
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      
      // 连接音频节点
      this.connectAudioNodes();
    } catch (error) {
      console.error('Failed to initialize audio context:', error);
    }
  }
  
  private connectAudioNodes(): void {
    if (!this.audioContext || !this.gainNode || !this.analyser) return;
    
    // 如果已有source，先断开
    if (this.source) {
      this.source.disconnect();
    }
    
    try {
      this.source = this.audioContext.createMediaElementSource(this.audio);
      this.source.connect(this.gainNode);
      this.gainNode.connect(this.analyser);
      this.analyser.connect(this.audioContext.destination);
    } catch (error) {
      console.error('Failed to connect audio nodes:', error);
    }
  }
  
  private emitEvent(event: AudioEvent): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach(listener => listener());
    }
  }
  
  // 公共方法实现
  async loadSong(song: Song): Promise<void> {
    this.currentSong = song;
    this.state = 'loading';
    
    if (!song.audioUrl) {
      throw new Error('Song audio URL is required');
    }
    
    return new Promise((resolve, reject) => {
      const handleCanPlay = () => {
        this.audio.removeEventListener('canplay', handleCanPlay);
        this.audio.removeEventListener('error', handleError);
        this.state = 'idle';
        resolve();
      };
      
      const handleError = () => {
        this.audio.removeEventListener('canplay', handleCanPlay);
        this.audio.removeEventListener('error', handleError);
        this.state = 'error';
        reject(new Error('Failed to load audio'));
      };
      
      this.audio.addEventListener('canplay', handleCanPlay);
      this.audio.addEventListener('error', handleError);
      
      this.audio.src = song.audioUrl;
      this.audio.load();
    });
  }
  
  async play(): Promise<void> {
    if (!this.audioContext) {
      await this.initializeAudioContext();
    }
    
    // 恢复音频上下文 (用户交互后)
    if (this.audioContext?.state === 'suspended') {
      await this.audioContext.resume();
    }
    
    try {
      await this.audio.play();
    } catch (error) {
      console.error('Failed to play audio:', error);
      throw error;
    }
  }
  
  pause(): void {
    this.audio.pause();
  }
  
  stop(): void {
    this.audio.pause();
    this.audio.currentTime = 0;
    this.state = 'idle';
  }
  
  seek(position: number): void {
    if (this.audio.duration && position >= 0 && position <= this.audio.duration) {
      this.audio.currentTime = position;
    }
  }
  
  setVolume(volume: number): void {
    const clampedVolume = Math.max(0, Math.min(1, volume));
    this.audio.volume = clampedVolume;
    
    if (this.gainNode) {
      this.gainNode.gain.value = clampedVolume;
    }
  }
  
  setMuted(muted: boolean): void {
    this.audio.muted = muted;
  }
  
  setPlaybackRate(rate: number): void {
    this.audio.playbackRate = Math.max(0.25, Math.min(2, rate));
  }
  
  getCurrentTime(): number {
    return this.audio.currentTime || 0;
  }
  
  getDuration(): number {
    return this.audio.duration || 0;
  }
  
  getBuffered(): TimeRanges {
    return this.audio.buffered;
  }
  
  getState(): PlaybackState {
    return this.state;
  }
  
  addEventListener(event: AudioEvent, handler: Function): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, new Set());
    }
    this.eventListeners.get(event)!.add(handler);
  }
  
  removeEventListener(event: AudioEvent, handler: Function): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.delete(handler);
    }
  }
  
  getFrequencyData(): Uint8Array {
    if (!this.analyser) return new Uint8Array(0);
    
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);
    return dataArray;
  }
  
  unload(): void {
    this.stop();
    this.audio.src = '';
    this.currentSong = null;
    this.state = 'idle';
  }
  
  // 清理资源
  dispose(): void {
    this.unload();
    
    if (this.source) {
      this.source.disconnect();
    }
    
    if (this.audioContext) {
      this.audioContext.close();
    }
    
    this.eventListeners.clear();
  }
}
```

### 2.2 播放队列管理系统

#### 步骤2.2.1: 创建播放队列接口
创建 `src/services/audio/PlayQueue.ts`:
```typescript
import { Song, PlayMode } from '../../types';

// 播放队列接口
export interface PlayQueue {
  // 队列操作
  addSong(song: Song, index?: number): void;
  removeSong(index: number): void;
  clearQueue(): void;
  moveSong(fromIndex: number, toIndex: number): void;
  
  // 播放控制
  next(): Song | null;
  previous(): Song | null;
  jumpTo(index: number): Song | null;
  
  // 模式控制
  setPlayMode(mode: PlayMode): void;
  shuffle(): void;
  
  // 状态查询
  getCurrentSong(): Song | null;
  getCurrentIndex(): number;
  getQueue(): Song[];
  getQueueLength(): number;
  
  // 事件监听
  onQueueChange(callback: (queue: Song[]) => void): void;
  onCurrentChange(callback: (song: Song | null, index: number) => void): void;
}

export class MusicPlayQueue implements PlayQueue {
  private queue: Song[] = [];
  private currentIndex: number = -1;
  private playMode: PlayMode = PlayMode.SEQUENCE;
  private shuffleIndices: number[] = [];
  private originalQueue: Song[] = [];
  private playHistory: number[] = [];
  
  // 事件回调
  private queueChangeCallbacks = new Set<(queue: Song[]) => void>();
  private currentChangeCallbacks = new Set<(song: Song | null, index: number) => void>();
  
  constructor() {
    this.generateShuffleIndices();
  }
  
  private generateShuffleIndices(): void {
    this.shuffleIndices = Array.from(
      { length: this.queue.length }, 
      (_, i) => i
    ).sort(() => Math.random() - 0.5);
  }
  
  private emitQueueChange(): void {
    this.queueChangeCallbacks.forEach(callback => callback(this.queue));
  }
  
  private emitCurrentChange(): void {
    const currentSong = this.getCurrentSong();
    this.currentChangeCallbacks.forEach(callback => 
      callback(currentSong, this.currentIndex)
    );
  }
  
  // 队列操作
  addSong(song: Song, index?: number): void {
    if (index !== undefined && index >= 0 && index <= this.queue.length) {
      this.queue.splice(index, 0, song);
      if (index <= this.currentIndex) {
        this.currentIndex++;
      }
    } else {
      this.queue.push(song);
    }
    
    this.generateShuffleIndices();
    this.emitQueueChange();
  }
  
  removeSong(index: number): void {
    if (index >= 0 && index < this.queue.length) {
      this.queue.splice(index, 1);
      
      if (index < this.currentIndex) {
        this.currentIndex--;
      } else if (index === this.currentIndex) {
        // 如果删除的是当前歌曲，重新设定当前位置
        if (this.currentIndex >= this.queue.length) {
          this.currentIndex = this.queue.length - 1;
        }
        this.emitCurrentChange();
      }
      
      this.generateShuffleIndices();
      this.emitQueueChange();
    }
  }
  
  clearQueue(): void {
    this.queue = [];
    this.currentIndex = -1;
    this.shuffleIndices = [];
    this.playHistory = [];
    this.emitQueueChange();
    this.emitCurrentChange();
  }
  
  moveSong(fromIndex: number, toIndex: number): void {
    if (fromIndex >= 0 && fromIndex < this.queue.length &&
        toIndex >= 0 && toIndex < this.queue.length &&
        fromIndex !== toIndex) {
      
      const song = this.queue.splice(fromIndex, 1)[0];
      this.queue.splice(toIndex, 0, song);
      
      // 更新当前索引
      if (fromIndex === this.currentIndex) {
        this.currentIndex = toIndex;
      } else if (fromIndex < this.currentIndex && toIndex >= this.currentIndex) {
        this.currentIndex--;
      } else if (fromIndex > this.currentIndex && toIndex <= this.currentIndex) {
        this.currentIndex++;
      }
      
      this.generateShuffleIndices();
      this.emitQueueChange();
      this.emitCurrentChange();
    }
  }
  
  // 播放控制
  next(): Song | null {
    switch (this.playMode) {
      case PlayMode.SEQUENCE:
        return this.getNextSequential();
      case PlayMode.RANDOM:
        return this.getNextRandom();
      case PlayMode.SINGLE:
        return this.getCurrentSong();
      case PlayMode.LIST_LOOP:
        return this.getNextLoop();
      default:
        return null;
    }
  }
  
  private getNextSequential(): Song | null {
    if (this.currentIndex < this.queue.length - 1) {
      this.currentIndex++;
      this.emitCurrentChange();
      return this.queue[this.currentIndex];
    }
    return null;
  }
  
  private getNextRandom(): Song | null {
    if (this.queue.length === 0) return null;
    
    // 避免重复播放最近的歌曲
    const maxHistorySize = Math.min(5, Math.floor(this.queue.length / 2));
    let attempts = 0;
    let nextIndex;
    
    do {
      nextIndex = Math.floor(Math.random() * this.queue.length);
      attempts++;
    } while (
      this.playHistory.includes(nextIndex) && 
      attempts < 10 && 
      this.playHistory.length < this.queue.length
    );
    
    this.currentIndex = nextIndex;
    
    // 更新播放历史
    this.playHistory.push(nextIndex);
    if (this.playHistory.length > maxHistorySize) {
      this.playHistory.shift();
    }
    
    this.emitCurrentChange();
    return this.queue[this.currentIndex];
  }
  
  private getNextLoop(): Song | null {
    if (this.queue.length === 0) return null;
    
    this.currentIndex = (this.currentIndex + 1) % this.queue.length;
    this.emitCurrentChange();
    return this.queue[this.currentIndex];
  }
  
  previous(): Song | null {
    switch (this.playMode) {
      case PlayMode.SEQUENCE:
      case PlayMode.LIST_LOOP:
        return this.getPreviousSequential();
      case PlayMode.RANDOM:
        return this.getPreviousRandom();
      case PlayMode.SINGLE:
        return this.getCurrentSong();
      default:
        return null;
    }
  }
  
  private getPreviousSequential(): Song | null {
    if (this.playMode === PlayMode.LIST_LOOP && this.currentIndex === 0) {
      this.currentIndex = this.queue.length - 1;
    } else if (this.currentIndex > 0) {
      this.currentIndex--;
    } else {
      return null;
    }
    
    this.emitCurrentChange();
    return this.queue[this.currentIndex];
  }
  
  private getPreviousRandom(): Song | null {
    if (this.playHistory.length > 1) {
      this.playHistory.pop(); // 移除当前
      const previousIndex = this.playHistory.pop(); // 获取上一首
      if (previousIndex !== undefined) {
        this.currentIndex = previousIndex;
        this.emitCurrentChange();
        return this.queue[this.currentIndex];
      }
    }
    
    // 如果没有历史，随机选择
    return this.getNextRandom();
  }
  
  jumpTo(index: number): Song | null {
    if (index >= 0 && index < this.queue.length) {
      this.currentIndex = index;
      this.emitCurrentChange();
      return this.queue[this.currentIndex];
    }
    return null;
  }
  
  // 模式控制
  setPlayMode(mode: PlayMode): void {
    this.playMode = mode;
    
    if (mode === PlayMode.RANDOM) {
      this.generateShuffleIndices();
      this.playHistory = [];
    }
  }
  
  shuffle(): void {
    if (this.queue.length <= 1) return;
    
    const currentSong = this.getCurrentSong();
    
    // Fisher-Yates 洗牌算法
    for (let i = this.queue.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.queue[i], this.queue[j]] = [this.queue[j], this.queue[i]];
    }
    
    // 保持当前歌曲位置
    if (currentSong) {
      const newIndex = this.queue.findIndex(song => song.id === currentSong.id);
      if (newIndex !== -1) {
        this.currentIndex = newIndex;
      }
    }
    
    this.generateShuffleIndices();
    this.emitQueueChange();
    this.emitCurrentChange();
  }
  
  // 状态查询
  getCurrentSong(): Song | null {
    return this.currentIndex >= 0 && this.currentIndex < this.queue.length 
      ? this.queue[this.currentIndex] 
      : null;
  }
  
  getCurrentIndex(): number {
    return this.currentIndex;
  }
  
  getQueue(): Song[] {
    return [...this.queue];
  }
  
  getQueueLength(): number {
    return this.queue.length;
  }
  
  // 事件监听
  onQueueChange(callback: (queue: Song[]) => void): void {
    this.queueChangeCallbacks.add(callback);
  }
  
  onCurrentChange(callback: (song: Song | null, index: number) => void): void {
    this.currentChangeCallbacks.add(callback);
  }
  
  // 移除事件监听
  offQueueChange(callback: (queue: Song[]) => void): void {
    this.queueChangeCallbacks.delete(callback);
  }
  
  offCurrentChange(callback: (song: Song | null, index: number) => void): void {
    this.currentChangeCallbacks.delete(callback);
  }
}
```

### 2.3 音频服务集成

#### 步骤2.3.1: 创建统一音频服务
创建 `src/services/audio/AudioService.ts`:
```typescript
import { WebAudioEngine } from './WebAudioEngine';
import { MusicPlayQueue } from './PlayQueue';
import { Song, PlayMode } from '../../types';
import { AudioEngine, PlaybackState } from './types';

export class AudioService {
  private audioEngine: AudioEngine;
  private playQueue: MusicPlayQueue;
  private isInitialized = false;
  
  constructor() {
    this.audioEngine = new WebAudioEngine();
    this.playQueue = new MusicPlayQueue();
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    // 监听播放结束事件，自动播放下一首
    this.audioEngine.addEventListener('ended', () => {
      this.playNext();
    });
    
    // 监听播放错误，尝试播放下一首
    this.audioEngine.addEventListener('error', () => {
      console.error('Audio playback error, trying next song');
      setTimeout(() => this.playNext(), 1000);
    });
  }
  
  async initialize(): Promise<void> {
    if (this.isInitialized) return;
    
    try {
      // 初始化音频引擎
      this.isInitialized = true;
    } catch (error) {
      console.error('Failed to initialize audio service:', error);
      throw error;
    }
  }
  
  // 播放控制
  async play(song?: Song): Promise<void> {
    await this.initialize();
    
    if (song) {
      // 播放指定歌曲
      await this.loadAndPlay(song);
    } else {
      // 继续播放当前歌曲
      await this.audioEngine.play();
    }
  }
  
  private async loadAndPlay(song: Song): Promise<void> {
    try {
      await this.audioEngine.loadSong(song);
      await this.audioEngine.play();
    } catch (error) {
      console.error('Failed to load and play song:', error);
      throw error;
    }
  }
  
  pause(): void {
    this.audioEngine.pause();
  }
  
  stop(): void {
    this.audioEngine.stop();
  }
  
  async playNext(): Promise<void> {
    const nextSong = this.playQueue.next();
    if (nextSong) {
      await this.play(nextSong);
    }
  }
  
  async playPrevious(): Promise<void> {
    const previousSong = this.playQueue.previous();
    if (previousSong) {
      await this.play(previousSong);
    }
  }
  
  async jumpToSong(index: number): Promise<void> {
    const song = this.playQueue.jumpTo(index);
    if (song) {
      await this.play(song);
    }
  }
  
  // 音频控制
  seek(position: number): void {
    this.audioEngine.seek(position);
  }
  
  setVolume(volume: number): void {
    this.audioEngine.setVolume(volume);
  }
  
  setMuted(muted: boolean): void {
    this.audioEngine.setMuted(muted);
  }
  
  // 播放模式
  setPlayMode(mode: PlayMode): void {
    this.playQueue.setPlayMode(mode);
  }
  
  shuffleQueue(): void {
    this.playQueue.shuffle();
  }
  
  // 队列管理
  addToQueue(song: Song, index?: number): void {
    this.playQueue.addSong(song, index);
  }
  
  removeFromQueue(index: number): void {
    this.playQueue.removeSong(index);
  }
  
  clearQueue(): void {
    this.playQueue.clearQueue();
    this.stop();
  }
  
  setQueue(songs: Song[], startIndex = 0): void {
    this.clearQueue();
    songs.forEach(song => this.addToQueue(song));
    if (songs.length > 0 && startIndex >= 0 && startIndex < songs.length) {
      this.playQueue.jumpTo(startIndex);
    }
  }
  
  // 状态查询
  getCurrentSong(): Song | null {
    return this.playQueue.getCurrentSong();
  }
  
  getQueue(): Song[] {
    return this.playQueue.getQueue();
  }
  
  getCurrentTime(): number {
    return this.audioEngine.getCurrentTime();
  }
  
  getDuration(): number {
    return this.audioEngine.getDuration();
  }
  
  getState(): PlaybackState {
    return this.audioEngine.getState();
  }
  
  getFrequencyData(): Uint8Array {
    return this.audioEngine.getFrequencyData();
  }
  
  // 事件监听
  addEventListener(event: string, handler: Function): void {
    if (event.startsWith('queue_')) {
      // 队列事件
      const queueEvent = event.replace('queue_', '');
      if (queueEvent === 'change') {
        this.playQueue.onQueueChange(handler as any);
      } else if (queueEvent === 'current_change') {
        this.playQueue.onCurrentChange(handler as any);
      }
    } else {
      // 音频事件
      this.audioEngine.addEventListener(event as any, handler);
    }
  }
  
  removeEventListener(event: string, handler: Function): void {
    if (event.startsWith('queue_')) {
      // 队列事件移除
      const queueEvent = event.replace('queue_', '');
      if (queueEvent === 'change') {
        this.playQueue.offQueueChange(handler as any);
      } else if (queueEvent === 'current_change') {
        this.playQueue.offCurrentChange(handler as any);
      }
    } else {
      // 音频事件
      this.audioEngine.removeEventListener(event as any, handler);
    }
  }
  
  // 清理资源
  dispose(): void {
    this.clearQueue();
    
    if (this.audioEngine && 'dispose' in this.audioEngine) {
      (this.audioEngine as any).dispose();
    }
  }
}

// 单例模式
export const audioService = new AudioService();
```

### 2.4 验收标准

#### 阶段2完成检查清单：
- [ ] ✅ 音频引擎可以正常播放、暂停、停止
- [ ] ✅ 播放队列管理功能完整（添加、删除、移动）
- [ ] ✅ 播放模式切换正常（顺序、随机、单曲、循环）
- [ ] ✅ 音量控制和进度控制正常
- [ ] ✅ 事件监听机制工作正常
- [ ] ✅ 音频可视化数据获取正常
- [ ] ✅ 统一音频服务接口完整

**测试方法：**
```typescript
// 创建测试文件 src/services/audio/__tests__/AudioService.test.ts
import { audioService } from '../AudioService';
import { Song, MusicSource, AudioQuality } from '../../../types';

const testSong: Song = {
  id: 'test-1',
  title: 'Test Song',
  artist: 'Test Artist',
  album: 'Test Album',
  duration: 180,
  coverUrl: 'https://example.com/cover.jpg',
  audioUrl: 'https://example.com/audio.mp3',
  source: MusicSource.LOCAL,
  quality: AudioQuality.STANDARD
};

describe('AudioService', () => {
  beforeEach(() => {
    audioService.clearQueue();
  });
  
  test('should add song to queue', () => {
    audioService.addToQueue(testSong);
    expect(audioService.getQueue()).toHaveLength(1);
    expect(audioService.getQueue()[0]).toBe(testSong);
  });
  
  test('should play song', async () => {
    audioService.addToQueue(testSong);
    await audioService.play(testSong);
    expect(audioService.getCurrentSong()).toBe(testSong);
  });
  
  // 更多测试用例...
});
```

---

## 🎨 阶段3: UI组件开发 (第5-7周)

### 3.1 基础组件库搭建

#### 步骤3.1.1: 创建基础UI组件
创建 `src/components/common/Button.tsx`:
```typescript
import React from 'react';
import { cn } from '../../utils';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'primary' | 'secondary' | 'ghost' | 'destructive';
  size?: 'sm' | 'md' | 'lg' | 'xl';
  loading?: boolean;
  icon?: React.ReactNode;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ 
    className, 
    variant = 'default', 
    size = 'md', 
    loading = false,
    icon,
    children, 
    disabled,
    ...props 
  }, ref) => {
    const baseClasses = 'inline-flex items-center justify-center rounded-lg font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none';
    
    const variants = {
      default: 'bg-white text-gray-900 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500',
      primary: 'bg-netease text-white hover:bg-red-600 focus:ring-red-500',
      secondary: 'bg-gray-100 text-gray-900 hover:bg-gray-200 focus:ring-gray-500',
      ghost: 'text-gray-600 hover:text-gray-900 hover:bg-gray-100 focus:ring-gray-500',
      destructive: 'bg-red-500 text-white hover:bg-red-600 focus:ring-red-500',
    };
    
    const sizes = {
      sm: 'h-8 px-3 text-sm',
      md: 'h-10 px-4 text-sm',
      lg: 'h-12 px-6 text-base',
      xl: 'h-14 px-8 text-lg',
    };
    
    return (
      <button
        className={cn(
          baseClasses,
          variants[variant],
          sizes[size],
          className
        )}
        ref={ref}
        disabled={disabled || loading}
        {...props}
      >
        {loading && (
          <svg className="animate-spin -ml-1 mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        )}
        {icon && !loading && <span className="mr-2">{icon}</span>}
        {children}
      </button>
    );
  }
);

Button.displayName = 'Button';
```

#### 步骤3.1.2: 创建滑块组件
创建 `src/components/common/Slider.tsx`:
```typescript
import React, { useState, useCallback, useRef, useEffect } from 'react';
import { cn } from '../../utils';

interface SliderProps {
  value: number;
  max: number;
  min?: number;
  step?: number;
  onChange: (value: number) => void;
  onDragStart?: () => void;
  onDragEnd?: () => void;
  className?: string;
  disabled?: boolean;
  showTooltip?: boolean;
  formatTooltip?: (value: number) => string;
}

export const Slider: React.FC<SliderProps> = ({
  value,
  max,
  min = 0,
  step = 1,
  onChange,
  onDragStart,
  onDragEnd,
  className,
  disabled = false,
  showTooltip = false,
  formatTooltip = (val) => val.toString(),
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [dragValue, setDragValue] = useState(value);
  const sliderRef = useRef<HTMLDivElement>(null);
  
  const percentage = max > min ? ((isDragging ? dragValue : value) - min) / (max - min) * 100 : 0;
  
  const updateValue = useCallback((clientX: number) => {
    if (!sliderRef.current || disabled) return;
    
    const rect = sliderRef.current.getBoundingClientRect();
    const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    const newValue = min + percent * (max - min);
    const steppedValue = Math.round(newValue / step) * step;
    const clampedValue = Math.max(min, Math.min(max, steppedValue));
    
    if (isDragging) {
      setDragValue(clampedValue);
    } else {
      onChange(clampedValue);
    }
  }, [min, max, step, isDragging, disabled, onChange]);
  
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (disabled) return;
    
    setIsDragging(true);
    onDragStart?.();
    updateValue(e.clientX);
    
    const handleMouseMove = (e: MouseEvent) => {
      updateValue(e.clientX);
    };
    
    const handleMouseUp = () => {
      setIsDragging(false);
      onChange(dragValue);
      onDragEnd?.();
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [disabled, dragValue, onChange, onDragStart, onDragEnd, updateValue]);
  
  const handleTrackClick = useCallback((e: React.MouseEvent) => {
    if (disabled || isDragging) return;
    updateValue(e.clientX);
  }, [disabled, isDragging, updateValue]);
  
  return (
    <div className={cn('relative w-full', className)}>
      <div
        ref={sliderRef}
        className={cn(
          'relative h-2 bg-gray-200 rounded-full cursor-pointer',
          disabled && 'cursor-not-allowed opacity-50'
        )}
        onMouseDown={handleTrackClick}
      >
        {/* 进度条 */}
        <div
          className="absolute h-full bg-netease rounded-full"
          style={{ width: `${percentage}%` }}
        />
        
        {/* 滑块 */}
        <div
          className={cn(
            'absolute w-4 h-4 bg-white border-2 border-netease rounded-full shadow-sm transform -translate-x-1/2 -translate-y-1/2 top-1/2 cursor-grab',
            isDragging && 'cursor-grabbing scale-110',
            disabled && 'cursor-not-allowed'
          )}
          style={{ left: `${percentage}%` }}
          onMouseDown={handleMouseDown}
        />
        
        {/* 提示框 */}
        {showTooltip && isDragging && (
          <div
            className="absolute bottom-6 transform -translate-x-1/2 px-2 py-1 bg-gray-900 text-white text-xs rounded whitespace-nowrap"
            style={{ left: `${percentage}%` }}
          >
            {formatTooltip(isDragging ? dragValue : value)}
          </div>
        )}
      </div>
    </div>
  );
};
```

### 3.2 播放器控制组件

#### 步骤3.2.1: 创建播放控制按钮组
创建 `src/components/player/PlayControls.tsx`:
```typescript
import React from 'react';
import { Play, Pause, SkipBack, SkipForward, Shuffle, Repeat, Repeat1 } from 'lucide-react';
import { Button } from '../common/Button';
import { PlayMode } from '../../types';
import { cn } from '../../utils';

interface PlayControlsProps {
  isPlaying: boolean;
  playMode: PlayMode;
  onPlay: () => void;
  onPause: () => void;
  onNext: () => void;
  onPrevious: () => void;
  onShuffle: () => void;
  onPlayModeChange: (mode: PlayMode) => void;
  disabled?: boolean;
  className?: string;
}

export const PlayControls: React.FC<PlayControlsProps> = ({
  isPlaying,
  playMode,
  onPlay,
  onPause,
  onNext,
  onPrevious,
  onShuffle,
  onPlayModeChange,
  disabled = false,
  className,
}) => {
  const handlePlayModeClick = () => {
    const modes = [PlayMode.SEQUENCE, PlayMode.LIST_LOOP, PlayMode.SINGLE];
    const currentIndex = modes.indexOf(playMode);
    const nextIndex = (currentIndex + 1) % modes.length;
    onPlayModeChange(modes[nextIndex]);
  };
  
  const getPlayModeIcon = () => {
    switch (playMode) {
      case PlayMode.SINGLE:
        return <Repeat1 className="w-4 h-4" />;
      case PlayMode.LIST_LOOP:
        return <Repeat className="w-4 h-4" />;
      case PlayMode.RANDOM:
        return <Shuffle className="w-4 h-4 text-netease" />;
      default:
        return <Repeat className="w-4 h-4" />;
    }
  };
  
  const getPlayModeTooltip = () => {
    switch (playMode) {
      case PlayMode.SEQUENCE:
        return '顺序播放';
      case PlayMode.LIST_LOOP:
        return '列表循环';
      case PlayMode.SINGLE:
        return '单曲循环';
      case PlayMode.RANDOM:
        return '随机播放';
      default:
        return '播放模式';
    }
  };
  
  return (
    <div className={cn('flex items-center space-x-2', className)}>
      {/* 播放模式 */}
      <Button
        variant="ghost"
        size="sm"
        onClick={handlePlayModeClick}
        disabled={disabled}
        title={getPlayModeTooltip()}
        className="text-gray-600 hover:text-gray-900"
      >
        {getPlayModeIcon()}
      </Button>
      
      {/* 上一首 */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onPrevious}
        disabled={disabled}
        title="上一首"
        className="text-gray-600 hover:text-gray-900"
      >
        <SkipBack className="w-5 h-5" />
      </Button>
      
      {/* 播放/暂停 */}
      <Button
        variant="primary"
        size="lg"
        onClick={isPlaying ? onPause : onPlay}
        disabled={disabled}
        title={isPlaying ? '暂停' : '播放'}
        className="bg-netease hover:bg-red-600 text-white rounded-full w-12 h-12"
      >
        {isPlaying ? (
          <Pause className="w-6 h-6" />
        ) : (
          <Play className="w-6 h-6 ml-0.5" />
        )}
      </Button>
      
      {/* 下一首 */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onNext}
        disabled={disabled}
        title="下一首"
        className="text-gray-600 hover:text-gray-900"
      >
        <SkipForward className="w-5 h-5" />
      </Button>
      
      {/* 随机播放 */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onShuffle}
        disabled={disabled}
        title="随机播放"
        className={cn(
          'text-gray-600 hover:text-gray-900',
          playMode === PlayMode.RANDOM && 'text-netease'
        )}
      >
        <Shuffle className="w-4 h-4" />
      </Button>
    </div>
  );
};
```

#### 步骤3.2.2: 创建进度条组件
创建 `src/components/player/ProgressBar.tsx`:
```typescript
import React, { useState, useCallback } from 'react';
import { Slider } from '../common/Slider';
import { formatTime, cn } from '../../utils';

interface ProgressBarProps {
  currentTime: number;
  duration: number;
  buffered?: number;
  onSeek: (time: number) => void;
  onSeekStart?: () => void;
  onSeekEnd?: () => void;
  className?: string;
  disabled?: boolean;
}

export const ProgressBar: React.FC<ProgressBarProps> = ({
  currentTime,
  duration,
  buffered = 0,
  onSeek,
  onSeekStart,
  onSeekEnd,
  className,
  disabled = false,
}) => {
  const [isPreview, setIsPreview] = useState(false);
  const [previewTime, setPreviewTime] = useState(0);
  
  const bufferedPercent = duration ? (buffered / duration) * 100 : 0;
  
  const handleSeekStart = useCallback(() => {
    setIsPreview(true);
    onSeekStart?.();
  }, [onSeekStart]);
  
  const handleSeekEnd = useCallback(() => {
    setIsPreview(false);
    onSeekEnd?.();
  }, [onSeekEnd]);
  
  const handleSeek = useCallback((value: number) => {
    if (isPreview) {
      setPreviewTime(value);
    } else {
      onSeek(value);
    }
  }, [isPreview, onSeek]);
  
  const displayTime = isPreview ? previewTime : currentTime;
  
  return (
    <div className={cn('w-full px-3', className)}>
      <div className="flex items-center space-x-3 text-xs text-gray-500">
        {/* 当前时间 */}
        <span className="w-10 text-right">
          {formatTime(displayTime)}
        </span>
        
        {/* 进度条容器 */}
        <div className="flex-1 relative">
          {/* 缓冲进度背景 */}
          <div className="absolute inset-0 h-1 bg-gray-200 rounded-full">
            <div
              className="h-full bg-gray-300 rounded-full transition-all duration-300"
              style={{ width: `${bufferedPercent}%` }}
            />
          </div>
          
          {/* 主进度条 */}
          <Slider
            value={displayTime}
            max={duration || 100}
            min={0}
            step={0.1}
            onChange={handleSeek}
            onDragStart={handleSeekStart}
            onDragEnd={handleSeekEnd}
            disabled={disabled || !duration}
            showTooltip={isPreview}
            formatTooltip={formatTime}
            className="relative z-10"
          />
        </div>
        
        {/* 总时长 */}
        <span className="w-10">
          {formatTime(duration)}
        </span>
      </div>
    </div>
  );
};
```

#### 步骤3.2.3: 创建音量控制组件
创建 `src/components/player/VolumeControl.tsx`:
```typescript
import React, { useState } from 'react';
import { Volume2, VolumeX, Volume1 } from 'lucide-react';
import { Button } from '../common/Button';
import { Slider } from '../common/Slider';
import { cn } from '../../utils';

interface VolumeControlProps {
  volume: number;
  isMuted: boolean;
  onVolumeChange: (volume: number) => void;
  onMuteToggle: () => void;
  className?: string;
  showSlider?: boolean;
}

export const VolumeControl: React.FC<VolumeControlProps> = ({
  volume,
  isMuted,
  onVolumeChange,
  onMuteToggle,
  className,
  showSlider = true,
}) => {
  const [showVolumeSlider, setShowVolumeSlider] = useState(false);
  
  const getVolumeIcon = () => {
    if (isMuted || volume === 0) {
      return <VolumeX className="w-5 h-5" />;
    } else if (volume < 0.5) {
      return <Volume1 className="w-5 h-5" />;
    } else {
      return <Volume2 className="w-5 h-5" />;
    }
  };
  
  const displayVolume = isMuted ? 0 : volume;
  
  return (
    <div className={cn('flex items-center space-x-2', className)}>
      {/* 音量按钮 */}
      <Button
        variant="ghost"
        size="sm"
        onClick={onMuteToggle}
        onMouseEnter={() => setShowVolumeSlider(true)}
        onMouseLeave={() => setShowVolumeSlider(false)}
        className="text-gray-600 hover:text-gray-900"
        title={isMuted ? '取消静音' : '静音'}
      >
        {getVolumeIcon()}
      </Button>
      
      {/* 音量滑块 */}
      {showSlider && (
        <div
          className={cn(
            'relative',
            showVolumeSlider ? 'w-20' : 'w-0 overflow-hidden'
          )}
          onMouseEnter={() => setShowVolumeSlider(true)}
          onMouseLeave={() => setShowVolumeSlider(false)}
        >
          <Slider
            value={displayVolume}
            max={1}
            min={0}
            step={0.01}
            onChange={onVolumeChange}
            className="transition-all duration-200"
            showTooltip={true}
            formatTooltip={(val) => `${Math.round(val * 100)}%`}
          />
        </div>
      )}
    </div>
  );
};
```

### 3.3 歌曲信息显示组件

#### 步骤3.3.1: 创建歌曲信息组件
创建 `src/components/player/SongInfo.tsx`:
```typescript
import React, { useState } from 'react';
import { Heart, MoreHorizontal } from 'lucide-react';
import { Button } from '../common/Button';
import { Song } from '../../types';
import { cn } from '../../utils';

interface SongInfoProps {
  song: Song | null;
  isFavorite?: boolean;
  onFavoriteToggle?: () => void;
  onMoreClick?: () => void;
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  showControls?: boolean;
}

export const SongInfo: React.FC<SongInfoProps> = ({
  song,
  isFavorite = false,
  onFavoriteToggle,
  onMoreClick,
  className,
  size = 'md',
  showControls = true,
}) => {
  const [imageError, setImageError] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  
  if (!song) {
    return (
      <div className={cn('flex items-center space-x-3', className)}>
        <div className={cn(
          'bg-gray-200 rounded flex items-center justify-center',
          size === 'sm' && 'w-10 h-10',
          size === 'md' && 'w-12 h-12',
          size === 'lg' && 'w-16 h-16'
        )}>
          <span className="text-gray-400 text-xs">♪</span>
        </div>
        <div className="flex-1 min-w-0">
          <div className={cn(
            'text-gray-400',
            size === 'sm' && 'text-sm',
            size === 'md' && 'text-base',
            size === 'lg' && 'text-lg'
          )}>
            未在播放
          </div>
        </div>
      </div>
    );
  }
  
  return (
    <div className={cn('flex items-center space-x-3', className)}>
      {/* 专辑封面 */}
      <div className={cn(
        'relative bg-gray-200 rounded overflow-hidden flex-shrink-0',
        size === 'sm' && 'w-10 h-10',
        size === 'md' && 'w-12 h-12',
        size === 'lg' && 'w-16 h-16'
      )}>
        {!imageError && song.coverUrl && (
          <img
            src={song.coverUrl}
            alt={song.title}
            className={cn(
              'w-full h-full object-cover transition-opacity duration-200',
              imageLoaded ? 'opacity-100' : 'opacity-0'
            )}
            onLoad={() => setImageLoaded(true)}
            onError={() => setImageError(true)}
          />
        )}
        {(imageError || !song.coverUrl || !imageLoaded) && (
          <div className="absolute inset-0 flex items-center justify-center">
            <span className="text-gray-400 text-xs">♪</span>
          </div>
        )}
      </div>
      
      {/* 歌曲信息 */}
      <div className="flex-1 min-w-0">
        <div className={cn(
          'font-medium text-gray-900 truncate',
          size === 'sm' && 'text-sm',
          size === 'md' && 'text-base',
          size === 'lg' && 'text-lg'
        )}>
          {song.title}
        </div>
        <div className={cn(
          'text-gray-500 truncate',
          size === 'sm' && 'text-xs',
          size === 'md' && 'text-sm',
          size === 'lg' && 'text-base'
        )}>
          {song.artist}
        </div>
        {size === 'lg' && (
          <div className="text-xs text-gray-400 truncate">
            {song.album}
          </div>
        )}
      </div>
      
      {/* 控制按钮 */}
      {showControls && (
        <div className="flex items-center space-x-1">
          <Button
            variant="ghost"
            size="sm"
            onClick={onFavoriteToggle}
            className={cn(
              'text-gray-400 hover:text-gray-600',
              isFavorite && 'text-red-500 hover:text-red-600'
            )}
            title={isFavorite ? '取消收藏' : '收藏'}
          >
            <Heart className={cn(
              'w-4 h-4',
              isFavorite && 'fill-current'
            )} />
          </Button>
          
          <Button
            variant="ghost"
            size="sm"
            onClick={onMoreClick}
            className="text-gray-400 hover:text-gray-600"
            title="更多选项"
          >
            <MoreHorizontal className="w-4 h-4" />
          </Button>
        </div>
      )}
    </div>
  );
};
```

### 3.4 验收标准

#### 阶段3完成检查清单：
- [ ] ✅ 基础UI组件库完整（Button、Slider等）
- [ ] ✅ 播放控制组件功能正常
- [ ] ✅ 进度条支持拖拽和预览
- [ ] ✅ 音量控制交互流畅
- [ ] ✅ 歌曲信息显示完整
- [ ] ✅ 组件响应式设计正常
- [ ] ✅ 组件可访问性支持

**测试方法：**
创建组件测试页面验证所有交互功能正常工作。

---

---

## 🔌 阶段4: API集成与数据管理 (第8-9周)

### 4.1 状态管理架构

#### 步骤4.1.1: 创建Zustand状态存储
创建 `src/stores/playerStore.ts`:
```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { Song, PlayMode, PlaybackState } from '../types';
import { audioService } from '../services/audio/AudioService';

interface PlayerState {
  // 播放器状态
  currentSong: Song | null;
  isPlaying: boolean;
  isPaused: boolean;
  isLoading: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  playMode: PlayMode;
  error: string | null;
  
  // 播放队列
  queue: Song[];
  currentIndex: number;
  
  // Actions
  play: (song?: Song) => Promise<void>;
  pause: () => void;
  stop: () => void;
  seek: (time: number) => void;
  next: () => Promise<void>;
  previous: () => Promise<void>;
  setVolume: (volume: number) => void;
  toggleMute: () => void;
  setPlayMode: (mode: PlayMode) => void;
  addToQueue: (song: Song, index?: number) => void;
  removeFromQueue: (index: number) => void;
  clearQueue: () => void;
  shuffleQueue: () => void;
  setQueue: (songs: Song[], startIndex?: number) => void;
  
  // 内部更新方法
  updateCurrentTime: (time: number) => void;
  updateDuration: (duration: number) => void;
  updatePlayingState: (isPlaying: boolean) => void;
  updateLoadingState: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
}

export const usePlayerStore = create<PlayerState>()(
  devtools(
    persist(
      (set, get) => ({
        // 初始状态
        currentSong: null,
        isPlaying: false,
        isPaused: false,
        isLoading: false,
        currentTime: 0,
        duration: 0,
        volume: 0.8,
        isMuted: false,
        playMode: PlayMode.SEQUENCE,
        error: null,
        queue: [],
        currentIndex: -1,
        
        // Actions
        play: async (song?: Song) => {
          const state = get();
          
          if (song) {
            // 播放指定歌曲
            set({ isLoading: true, error: null });
            
            try {
              await audioService.play(song);
              set({
                currentSong: song,
                isPlaying: true,
                isPaused: false,
                isLoading: false,
              });
            } catch (error) {
              set({
                isLoading: false,
                error: (error as Error).message,
              });
            }
          } else {
            // 继续播放当前歌曲
            if (state.currentSong) {
              try {
                await audioService.play();
                set({ isPlaying: true, isPaused: false });
              } catch (error) {
                set({ error: (error as Error).message });
              }
            }
          }
        },
        
        pause: () => {
          audioService.pause();
          set({ isPlaying: false, isPaused: true });
        },
        
        stop: () => {
          audioService.stop();
          set({ 
            isPlaying: false, 
            isPaused: false, 
            currentTime: 0 
          });
        },
        
        seek: (time: number) => {
          audioService.seek(time);
          set({ currentTime: time });
        },
        
        next: async () => {
          try {
            await audioService.playNext();
            const newSong = audioService.getCurrentSong();
            set({ 
              currentSong: newSong,
              currentIndex: get().queue.findIndex(s => s?.id === newSong?.id)
            });
          } catch (error) {
            set({ error: (error as Error).message });
          }
        },
        
        previous: async () => {
          try {
            await audioService.playPrevious();
            const newSong = audioService.getCurrentSong();
            set({ 
              currentSong: newSong,
              currentIndex: get().queue.findIndex(s => s?.id === newSong?.id)
            });
          } catch (error) {
            set({ error: (error as Error).message });
          }
        },
        
        setVolume: (volume: number) => {
          audioService.setVolume(volume);
          set({ volume, isMuted: false });
        },
        
        toggleMute: () => {
          const { isMuted } = get();
          audioService.setMuted(!isMuted);
          set({ isMuted: !isMuted });
        },
        
        setPlayMode: (mode: PlayMode) => {
          audioService.setPlayMode(mode);
          set({ playMode: mode });
        },
        
        addToQueue: (song: Song, index?: number) => {
          audioService.addToQueue(song, index);
          const newQueue = audioService.getQueue();
          set({ queue: newQueue });
        },
        
        removeFromQueue: (index: number) => {
          audioService.removeFromQueue(index);
          const newQueue = audioService.getQueue();
          set({ queue: newQueue });
        },
        
        clearQueue: () => {
          audioService.clearQueue();
          set({ 
            queue: [], 
            currentSong: null, 
            currentIndex: -1,
            isPlaying: false,
            isPaused: false 
          });
        },
        
        shuffleQueue: () => {
          audioService.shuffleQueue();
          const newQueue = audioService.getQueue();
          set({ queue: newQueue });
        },
        
        setQueue: (songs: Song[], startIndex = 0) => {
          audioService.setQueue(songs, startIndex);
          const newQueue = audioService.getQueue();
          set({ 
            queue: newQueue,
            currentIndex: startIndex 
          });
        },
        
        // 内部更新方法
        updateCurrentTime: (time: number) => set({ currentTime: time }),
        updateDuration: (duration: number) => set({ duration }),
        updatePlayingState: (isPlaying: boolean) => set({ isPlaying }),
        updateLoadingState: (isLoading: boolean) => set({ isLoading }),
        setError: (error: string | null) => set({ error }),
      }),
      {
        name: 'player-store',
        partialize: (state) => ({
          volume: state.volume,
          isMuted: state.isMuted,
          playMode: state.playMode,
        }),
      }
    )
  )
);

// 初始化音频服务事件监听
const initializeAudioListeners = () => {
  const store = usePlayerStore.getState();
  
  audioService.addEventListener('timeupdate', () => {
    store.updateCurrentTime(audioService.getCurrentTime());
  });
  
  audioService.addEventListener('loadeddata', () => {
    store.updateDuration(audioService.getDuration());
  });
  
  audioService.addEventListener('play', () => {
    store.updatePlayingState(true);
  });
  
  audioService.addEventListener('pause', () => {
    store.updatePlayingState(false);
  });
  
  audioService.addEventListener('ended', () => {
    store.updatePlayingState(false);
  });
  
  audioService.addEventListener('error', () => {
    store.setError('播放错误');
    store.updateLoadingState(false);
  });
};

// 在应用启动时调用
export { initializeAudioListeners };
```

### 4.2 音乐API服务层

#### 步骤4.2.1: 创建API抽象层
创建 `src/services/api/MusicAPIBase.ts`:
```typescript
import { Song, Album, Artist, Playlist, SearchResult, AudioQuality } from '../../types';

// 抽象音乐API接口
export abstract class MusicAPIBase {
  protected baseUrl: string;
  protected rateLimiter?: RateLimiter;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  // 搜索功能
  abstract search(
    keyword: string, 
    type: 'song' | 'album' | 'artist' | 'playlist',
    page?: number,
    pageSize?: number
  ): Promise<SearchResult>;
  
  // 获取歌曲详情
  abstract getSongDetail(songId: string): Promise<Song>;
  
  // 获取播放链接
  abstract getSongUrl(songId: string, quality?: AudioQuality): Promise<string>;
  
  // 获取歌词
  abstract getLyrics(songId: string): Promise<{ lyrics: string; translation?: string }>;
  
  // 获取专辑信息
  abstract getAlbum(albumId: string): Promise<Album>;
  
  // 获取艺术家信息
  abstract getArtist(artistId: string): Promise<Artist>;
  
  // 获取歌单信息
  abstract getPlaylist(playlistId: string): Promise<Playlist>;
  
  // 推荐和排行榜
  abstract getRecommendSongs(limit?: number): Promise<Song[]>;
  abstract getTopPlaylists(category?: string, limit?: number): Promise<Playlist[]>;
  abstract getTopSongs(type?: 'new' | 'hot', limit?: number): Promise<Song[]>;
  
  // 错误处理
  protected handleError(error: any, context: string): never {
    console.error(`API Error in ${context}:`, error);
    throw new Error(`${context} failed: ${error.message || 'Unknown error'}`);
  }
  
  // 请求工具方法
  protected async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        ...options,
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      return data;
    } catch (error) {
      this.handleError(error, `Request to ${endpoint}`);
    }
  }
}

// 请求限流器
export class RateLimiter {
  private requests: number[] = [];
  private maxRequests: number;
  private timeWindow: number;
  
  constructor(maxRequests: number, timeWindowMs: number) {
    this.maxRequests = maxRequests;
    this.timeWindow = timeWindowMs;
  }
  
  async wait(): Promise<void> {
    const now = Date.now();
    
    // 清理过期的请求记录
    this.requests = this.requests.filter(time => now - time < this.timeWindow);
    
    if (this.requests.length >= this.maxRequests) {
      // 需要等待
      const oldestRequest = Math.min(...this.requests);
      const waitTime = this.timeWindow - (now - oldestRequest);
      
      if (waitTime > 0) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    this.requests.push(now);
  }
}
```

#### 步骤4.2.2: 实现QQ音乐API
创建 `src/services/api/QQMusicAPI.ts`:
```typescript
import { MusicAPIBase } from './MusicAPIBase';
import { Song, Album, Artist, Playlist, SearchResult, MusicSource, AudioQuality } from '../../types';

export class QQMusicAPI extends MusicAPIBase {
  constructor() {
    super('https://api.qq.jsososo.com');
  }
  
  async search(
    keyword: string,
    type: 'song' | 'album' | 'artist' | 'playlist',
    page = 1,
    pageSize = 20
  ): Promise<SearchResult> {
    const typeMap = {
      song: 0,
      album: 8,
      artist: 9,
      playlist: 3
    };
    
    const data = await this.request('/search', {
      method: 'POST',
      body: JSON.stringify({
        key: keyword,
        pageNo: page,
        pageSize,
        t: typeMap[type]
      })
    });
    
    return this.transformSearchResult(data, type);
  }
  
  async getSongDetail(songId: string): Promise<Song> {
    const data = await this.request(`/song?songmid=${songId}`);
    return this.transformSong(data);
  }
  
  async getSongUrl(songId: string, quality = AudioQuality.STANDARD): Promise<string> {
    const data = await this.request(`/song/url?id=${songId}&quality=${quality}`);
    
    if (!data.url) {
      throw new Error('Unable to get song URL');
    }
    
    return data.url;
  }
  
  async getLyrics(songId: string): Promise<{ lyrics: string; translation?: string }> {
    const data = await this.request(`/lyric?songmid=${songId}`);
    
    return {
      lyrics: data.lyric || '',
      translation: data.trans || undefined
    };
  }
  
  async getAlbum(albumId: string): Promise<Album> {
    const data = await this.request(`/album?albummid=${albumId}`);
    return this.transformAlbum(data);
  }
  
  async getArtist(artistId: string): Promise<Artist> {
    const data = await this.request(`/artist?singermid=${artistId}`);
    return this.transformArtist(data);
  }
  
  async getPlaylist(playlistId: string): Promise<Playlist> {
    const data = await this.request(`/playlist?id=${playlistId}`);
    return this.transformPlaylist(data);
  }
  
  async getRecommendSongs(limit = 30): Promise<Song[]> {
    const data = await this.request(`/recommend?limit=${limit}`);
    return data.list.map((item: any) => this.transformSong(item));
  }
  
  async getTopPlaylists(category = '', limit = 20): Promise<Playlist[]> {
    const data = await this.request(`/top/playlist?cat=${category}&limit=${limit}`);
    return data.list.map((item: any) => this.transformPlaylist(item));
  }
  
  async getTopSongs(type = 'new', limit = 100): Promise<Song[]> {
    const data = await this.request(`/top/song?type=${type}&limit=${limit}`);
    return data.list.map((item: any) => this.transformSong(item));
  }
  
  // 数据转换方法
  private transformSearchResult(data: any, type: string): SearchResult {
    const result: SearchResult = {
      songs: [],
      albums: [],
      artists: [],
      playlists: [],
      total: data.total || 0,
      page: data.pageNo || 1,
      pageSize: data.pageSize || 20
    };
    
    if (data.list) {
      switch (type) {
        case 'song':
          result.songs = data.list.map((item: any) => this.transformSong(item));
          break;
        case 'album':
          result.albums = data.list.map((item: any) => this.transformAlbum(item));
          break;
        case 'artist':
          result.artists = data.list.map((item: any) => this.transformArtist(item));
          break;
        case 'playlist':
          result.playlists = data.list.map((item: any) => this.transformPlaylist(item));
          break;
      }
    }
    
    return result;
  }
  
  private transformSong(item: any): Song {
    return {
      id: item.songmid || item.id,
      title: item.songname || item.name,
      artist: Array.isArray(item.singer) 
        ? item.singer.map((s: any) => s.name).join('/')
        : item.singer || item.artist,
      album: item.albumname || item.album,
      duration: item.interval || item.duration || 0,
      coverUrl: item.albummid 
        ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${item.albummid}.jpg`
        : '',
      source: MusicSource.QQ_MUSIC,
      quality: AudioQuality.STANDARD
    };
  }
  
  private transformAlbum(item: any): Album {
    return {
      id: item.albummid || item.id,
      title: item.albumname || item.name,
      artist: item.singername || item.artist,
      coverUrl: item.albummid 
        ? `https://y.gtimg.cn/music/photo_new/T002R300x300M000${item.albummid}.jpg`
        : '',
      releaseDate: new Date(item.aDate || Date.now()),
      songs: item.list ? item.list.map((song: any) => this.transformSong(song)) : [],
      source: MusicSource.QQ_MUSIC
    };
  }
  
  private transformArtist(item: any): Artist {
    return {
      id: item.singermid || item.id,
      name: item.singername || item.name,
      avatarUrl: item.singermid 
        ? `https://y.gtimg.cn/music/photo_new/T001R150x150M000${item.singermid}.jpg`
        : '',
      description: item.desc || '',
      albums: item.albumlist ? item.albumlist.map((album: any) => this.transformAlbum(album)) : [],
      topSongs: item.songlist ? item.songlist.map((song: any) => this.transformSong(song)) : [],
      source: MusicSource.QQ_MUSIC
    };
  }
  
  private transformPlaylist(item: any): Playlist {
    return {
      id: item.dissid || item.id,
      title: item.dissname || item.name,
      description: item.desc || '',
      coverUrl: item.logo || '',
      creator: item.nickname || item.creator,
      songs: item.songlist ? item.songlist.map((song: any) => this.transformSong(song)) : [],
      isPublic: true,
      createdAt: new Date(item.createtime || Date.now()),
      updatedAt: new Date(item.createtime || Date.now())
    };
  }
}
```

### 4.3 数据缓存服务

#### 步骤4.3.1: 创建缓存管理器
创建 `src/services/cache/CacheManager.ts`:
```typescript
interface CacheItem<T = any> {
  data: T;
  timestamp: number;
  ttl: number;
  size: number;
  accessCount: number;
  lastAccessed: number;
}

interface CacheConfig {
  maxMemorySize?: number;
  defaultTTL?: number;
  persistentTTL?: number;
}

export class CacheManager {
  private memoryCache = new Map<string, CacheItem>();
  private readonly maxMemorySize: number;
  private readonly defaultTTL: number;
  private readonly persistentTTL: number;
  private currentMemorySize = 0;
  
  constructor(config: CacheConfig = {}) {
    this.maxMemorySize = config.maxMemorySize || 50 * 1024 * 1024; // 50MB
    this.defaultTTL = config.defaultTTL || 5 * 60 * 1000; // 5分钟
    this.persistentTTL = config.persistentTTL || 60 * 60 * 1000; // 1小时
  }
  
  // 获取缓存数据
  async get<T>(key: string): Promise<T | null> {
    // 优先从内存缓存获取
    const memoryItem = this.memoryCache.get(key);
    if (memoryItem && !this.isExpired(memoryItem)) {
      memoryItem.accessCount++;
      memoryItem.lastAccessed = Date.now();
      return memoryItem.data;
    }
    
    // 从持久化存储获取
    try {
      const persistentData = await this.getFromPersistentStorage(key);
      if (persistentData && !this.isExpired(persistentData)) {
        // 重新放入内存缓存
        this.setInMemory(key, persistentData.data, persistentData.ttl);
        return persistentData.data;
      }
    } catch (error) {
      console.warn('Failed to get from persistent storage:', error);
    }
    
    return null;
  }
  
  // 设置缓存数据
  async set<T>(key: string, data: T, ttl?: number): Promise<void> {
    const cacheTTL = ttl || this.defaultTTL;
    
    // 设置内存缓存
    this.setInMemory(key, data, cacheTTL);
    
    // 长期缓存存储到持久化存储
    if (cacheTTL >= this.persistentTTL) {
      try {
        await this.setToPersistentStorage(key, data, cacheTTL);
      } catch (error) {
        console.warn('Failed to set to persistent storage:', error);
      }
    }
  }
  
  // 删除缓存
  async delete(key: string): Promise<void> {
    this.memoryCache.delete(key);
    
    try {
      await this.deleteFromPersistentStorage(key);
    } catch (error) {
      console.warn('Failed to delete from persistent storage:', error);
    }
  }
  
  // 清空缓存
  async clear(): Promise<void> {
    this.memoryCache.clear();
    this.currentMemorySize = 0;
    
    try {
      await this.clearPersistentStorage();
    } catch (error) {
      console.warn('Failed to clear persistent storage:', error);
    }
  }
  
  // 检查是否存在
  async has(key: string): Promise<boolean> {
    const data = await this.get(key);
    return data !== null;
  }
  
  // 设置内存缓存
  private setInMemory<T>(key: string, data: T, ttl: number): void {
    const size = JSON.stringify(data).length * 2; // 估算大小
    
    const item: CacheItem<T> = {
      data,
      timestamp: Date.now(),
      ttl,
      size,
      accessCount: 1,
      lastAccessed: Date.now()
    };
    
    // 删除旧项目
    const oldItem = this.memoryCache.get(key);
    if (oldItem) {
      this.currentMemorySize -= oldItem.size;
    }
    
    this.memoryCache.set(key, item);
    this.currentMemorySize += size;
    
    // 检查内存限制
    this.evictIfNecessary();
  }
  
  // LRU内存淘汰策略
  private evictIfNecessary(): void {
    if (this.currentMemorySize <= this.maxMemorySize) return;
    
    // 按访问时间排序，优先淘汰最久未访问的
    const entries = Array.from(this.memoryCache.entries())
      .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);
    
    for (const [key, item] of entries) {
      this.memoryCache.delete(key);
      this.currentMemorySize -= item.size;
      
      if (this.currentMemorySize <= this.maxMemorySize * 0.8) {
        break;
      }
    }
  }
  
  // 检查是否过期
  private isExpired(item: CacheItem): boolean {
    return Date.now() - item.timestamp > item.ttl;
  }
  
  // 持久化存储方法 (使用 localStorage)
  private async getFromPersistentStorage(key: string): Promise<CacheItem | null> {
    try {
      const item = localStorage.getItem(`cache_${key}`);
      return item ? JSON.parse(item) : null;
    } catch {
      return null;
    }
  }
  
  private async setToPersistentStorage<T>(key: string, data: T, ttl: number): Promise<void> {
    const item: CacheItem<T> = {
      data,
      timestamp: Date.now(),
      ttl,
      size: 0,
      accessCount: 0,
      lastAccessed: Date.now()
    };
    
    try {
      localStorage.setItem(`cache_${key}`, JSON.stringify(item));
    } catch (error) {
      // 存储空间不足，清理一些过期项目
      this.cleanupPersistentStorage();
      throw error;
    }
  }
  
  private async deleteFromPersistentStorage(key: string): Promise<void> {
    localStorage.removeItem(`cache_${key}`);
  }
  
  private async clearPersistentStorage(): Promise<void> {
    const keys = Object.keys(localStorage).filter(key => key.startsWith('cache_'));
    keys.forEach(key => localStorage.removeItem(key));
  }
  
  private cleanupPersistentStorage(): void {
    const now = Date.now();
    const keys = Object.keys(localStorage).filter(key => key.startsWith('cache_'));
    
    for (const key of keys) {
      try {
        const item = JSON.parse(localStorage.getItem(key) || '');
        if (now - item.timestamp > item.ttl) {
          localStorage.removeItem(key);
        }
      } catch {
        localStorage.removeItem(key);
      }
    }
  }
  
  // 获取缓存统计
  getStats() {
    const memoryEntries = Array.from(this.memoryCache.values());
    
    return {
      memoryItems: memoryEntries.length,
      memorySize: this.currentMemorySize,
      maxMemorySize: this.maxMemorySize,
      hitRate: memoryEntries.length > 0 
        ? memoryEntries.reduce((sum, item) => sum + item.accessCount, 0) / memoryEntries.length 
        : 0
    };
  }
}

// 单例缓存管理器
export const cacheManager = new CacheManager();
```

### 4.4 API聚合服务

#### 步骤4.4.1: 创建统一音乐服务
创建 `src/services/api/MusicService.ts`:
```typescript
import { QQMusicAPI } from './QQMusicAPI';
import { MusicAPIBase } from './MusicAPIBase';
import { cacheManager } from '../cache/CacheManager';
import { 
  Song, 
  Album, 
  Artist, 
  Playlist, 
  SearchResult, 
  MusicSource,
  AudioQuality 
} from '../../types';

interface SearchOptions {
  page?: number;
  pageSize?: number;
  source?: MusicSource;
}

export class MusicService {
  private apis: Map<MusicSource, MusicAPIBase> = new Map();
  private fallbackOrder: MusicSource[] = [
    MusicSource.QQ_MUSIC,
    // 其他API可以在这里添加
  ];
  
  constructor() {
    this.apis.set(MusicSource.QQ_MUSIC, new QQMusicAPI());
  }
  
  // 搜索音乐
  async search(
    keyword: string,
    type: 'song' | 'album' | 'artist' | 'playlist' = 'song',
    options: SearchOptions = {}
  ): Promise<SearchResult> {
    const cacheKey = `search_${keyword}_${type}_${options.page || 1}_${options.pageSize || 20}`;
    
    // 尝试从缓存获取
    const cached = await cacheManager.get<SearchResult>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const errors: Error[] = [];
    const targetSources = options.source ? [options.source] : this.fallbackOrder;
    
    for (const source of targetSources) {
      try {
        const api = this.apis.get(source);
        if (api) {
          const result = await api.search(keyword, type, options.page, options.pageSize);
          
          if (result.total > 0) {
            // 缓存结果 (5分钟)
            await cacheManager.set(cacheKey, result, 5 * 60 * 1000);
            return result;
          }
        }
      } catch (error) {
        errors.push(error as Error);
        console.warn(`Search failed for source ${source}:`, error);
      }
    }
    
    // 所有API都失败了
    throw new Error(`All search APIs failed: ${errors.map(e => e.message).join(', ')}`);
  }
  
  // 获取歌曲详情
  async getSongDetail(songId: string, source?: MusicSource): Promise<Song> {
    const cacheKey = `song_detail_${songId}`;
    
    const cached = await cacheManager.get<Song>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const targetSources = source ? [source] : this.fallbackOrder;
    
    for (const src of targetSources) {
      try {
        const api = this.apis.get(src);
        if (api) {
          const song = await api.getSongDetail(songId);
          
          // 缓存结果 (30分钟)
          await cacheManager.set(cacheKey, song, 30 * 60 * 1000);
          return song;
        }
      } catch (error) {
        console.warn(`Get song detail failed for source ${src}:`, error);
      }
    }
    
    throw new Error(`Failed to get song detail for ${songId}`);
  }
  
  // 获取播放链接
  async getSongUrl(songId: string, quality = AudioQuality.STANDARD, source?: MusicSource): Promise<string> {
    const cacheKey = `song_url_${songId}_${quality}`;
    
    // URL缓存时间较短 (5分钟)
    const cached = await cacheManager.get<string>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const targetSources = source ? [source] : this.fallbackOrder;
    
    for (const src of targetSources) {
      try {
        const api = this.apis.get(src);
        if (api) {
          const url = await api.getSongUrl(songId, quality);
          
          if (url) {
            // 缓存URL (5分钟)
            await cacheManager.set(cacheKey, url, 5 * 60 * 1000);
            return url;
          }
        }
      } catch (error) {
        console.warn(`Get song URL failed for source ${src}:`, error);
      }
    }
    
    throw new Error(`Failed to get song URL for ${songId}`);
  }
  
  // 获取歌词
  async getLyrics(songId: string, source?: MusicSource): Promise<{ lyrics: string; translation?: string }> {
    const cacheKey = `lyrics_${songId}`;
    
    const cached = await cacheManager.get<{ lyrics: string; translation?: string }>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const targetSources = source ? [source] : this.fallbackOrder;
    
    for (const src of targetSources) {
      try {
        const api = this.apis.get(src);
        if (api) {
          const lyrics = await api.getLyrics(songId);
          
          if (lyrics.lyrics) {
            // 缓存歌词 (1小时)
            await cacheManager.set(cacheKey, lyrics, 60 * 60 * 1000);
            return lyrics;
          }
        }
      } catch (error) {
        console.warn(`Get lyrics failed for source ${src}:`, error);
      }
    }
    
    return { lyrics: '' }; // 返回空歌词而不是抛出错误
  }
  
  // 获取推荐歌曲
  async getRecommendSongs(limit = 30): Promise<Song[]> {
    const cacheKey = `recommend_songs_${limit}`;
    
    const cached = await cacheManager.get<Song[]>(cacheKey);
    if (cached) {
      return cached;
    }
    
    for (const source of this.fallbackOrder) {
      try {
        const api = this.apis.get(source);
        if (api) {
          const songs = await api.getRecommendSongs(limit);
          
          if (songs.length > 0) {
            // 缓存推荐结果 (30分钟)
            await cacheManager.set(cacheKey, songs, 30 * 60 * 1000);
            return songs;
          }
        }
      } catch (error) {
        console.warn(`Get recommend songs failed for source ${source}:`, error);
      }
    }
    
    return []; // 返回空数组而不是抛出错误
  }
  
  // 获取热门歌单
  async getTopPlaylists(category = '', limit = 20): Promise<Playlist[]> {
    const cacheKey = `top_playlists_${category}_${limit}`;
    
    const cached = await cacheManager.get<Playlist[]>(cacheKey);
    if (cached) {
      return cached;
    }
    
    for (const source of this.fallbackOrder) {
      try {
        const api = this.apis.get(source);
        if (api) {
          const playlists = await api.getTopPlaylists(category, limit);
          
          if (playlists.length > 0) {
            // 缓存榜单 (1小时)
            await cacheManager.set(cacheKey, playlists, 60 * 60 * 1000);
            return playlists;
          }
        }
      } catch (error) {
        console.warn(`Get top playlists failed for source ${source}:`, error);
      }
    }
    
    return [];
  }
  
  // 清除缓存
  async clearCache(): Promise<void> {
    await cacheManager.clear();
  }
  
  // 获取缓存统计
  getCacheStats() {
    return cacheManager.getStats();
  }
}

// 单例音乐服务
export const musicService = new MusicService();
```

### 4.5 验收标准

#### 阶段4完成检查清单：
- [ ] ✅ Zustand状态管理正常工作
- [ ] ✅ 音频服务与状态管理集成完成
- [ ] ✅ 音乐API抽象层设计完整
- [ ] ✅ QQ音乐API集成并能正常搜索和播放
- [ ] ✅ 缓存管理器功能完整
- [ ] ✅ API聚合服务支持多数据源
- [ ] ✅ 错误处理和降级策略完善

---

## 🎨 阶段5: 高级功能开发 (第10-11周)

### 5.1 歌词显示功能

#### 步骤5.1.1: 创建歌词解析器
创建 `src/services/lyrics/LyricsParser.ts`:
```typescript
export interface ParsedLyricLine {
  time: number;
  text: string;
  translation?: string;
}

export interface ParsedLyrics {
  lines: ParsedLyricLine[];
  offset: number;
  duration: number;
}

export class LyricsParser {
  // 解析LRC格式歌词
  static parseLRC(lrcText: string, translation?: string): ParsedLyrics {
    const lines: ParsedLyricLine[] = [];
    const lrcLines = lrcText.split('\n');
    const translationLines = translation ? translation.split('\n') : [];
    
    let offset = 0;
    let duration = 0;
    
    // 正则表达式匹配时间标签
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
    const offsetRegex = /\[offset:(-?\d+)\]/;
    
    for (let i = 0; i < lrcLines.length; i++) {
      const line = lrcLines[i].trim();
      
      // 解析offset
      const offsetMatch = line.match(offsetRegex);
      if (offsetMatch) {
        offset = parseInt(offsetMatch[1]);
        continue;
      }
      
      // 解析歌词行
      let match;
      const times: number[] = [];
      let text = line;
      
      // 提取所有时间标签
      while ((match = timeRegex.exec(line)) !== null) {
        const minutes = parseInt(match[1]);
        const seconds = parseInt(match[2]);
        const milliseconds = parseInt(match[3].padEnd(3, '0'));
        const totalMs = minutes * 60 * 1000 + seconds * 1000 + milliseconds;
        times.push(totalMs);
      }
      
      // 移除时间标签，获取歌词文本
      text = line.replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim();
      
      // 如果有歌词文本和时间，添加到结果中
      if (text && times.length > 0) {
        const translationText = translationLines[i] 
          ? translationLines[i].replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim()
          : undefined;
        
        times.forEach(time => {
          lines.push({
            time: time + offset,
            text,
            translation: translationText || undefined
          });
          
          duration = Math.max(duration, time + offset);
        });
      }
    }
    
    // 按时间排序
    lines.sort((a, b) => a.time - b.time);
    
    return {
      lines,
      offset,
      duration
    };
  }
  
  // 查找当前时间对应的歌词行
  static getCurrentLine(lyrics: ParsedLyrics, currentTime: number): ParsedLyricLine | null {
    if (!lyrics.lines.length) return null;
    
    // 转换为毫秒
    const timeMs = currentTime * 1000;
    
    let currentLine: ParsedLyricLine | null = null;
    
    for (const line of lyrics.lines) {
      if (line.time <= timeMs) {
        currentLine = line;
      } else {
        break;
      }
    }
    
    return currentLine;
  }
  
  // 获取歌词滚动位置
  static getScrollPosition(
    lyrics: ParsedLyrics, 
    currentTime: number, 
    containerHeight: number, 
    lineHeight: number
  ): number {
    const currentLine = this.getCurrentLine(lyrics, currentTime);
    if (!currentLine) return 0;
    
    const currentIndex = lyrics.lines.indexOf(currentLine);
    const visibleLines = Math.floor(containerHeight / lineHeight);
    const centerLine = Math.floor(visibleLines / 2);
    
    const scrollToIndex = Math.max(0, currentIndex - centerLine);
    return scrollToIndex * lineHeight;
  }
}
```

#### 步骤5.1.2: 创建歌词显示组件
创建 `src/components/player/LyricsDisplay.tsx`:
```typescript
import React, { useState, useEffect, useRef } from 'react';
import { musicService } from '../../services/api/MusicService';
import { LyricsParser, ParsedLyrics, ParsedLyricLine } from '../../services/lyrics/LyricsParser';
import { cn } from '../../utils';

interface LyricsDisplayProps {
  songId: string;
  currentTime: number;
  className?: string;
  showTranslation?: boolean;
  fontSize?: 'sm' | 'md' | 'lg';
  centered?: boolean;
}

export const LyricsDisplay: React.FC<LyricsDisplayProps> = ({
  songId,
  currentTime,
  className,
  showTranslation = false,
  fontSize = 'md',
  centered = false,
}) => {
  const [lyrics, setLyrics] = useState<ParsedLyrics | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentLine, setCurrentLine] = useState<ParsedLyricLine | null>(null);
  
  const containerRef = useRef<HTMLDivElement>(null);
  const currentLineRef = useRef<HTMLDivElement>(null);
  
  const lineHeight = fontSize === 'sm' ? 32 : fontSize === 'md' ? 40 : 48;
  
  // 加载歌词
  useEffect(() => {
    if (!songId) return;
    
    const loadLyrics = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const lyricsData = await musicService.getLyrics(songId);
        
        if (lyricsData.lyrics) {
          const parsed = LyricsParser.parseLRC(
            lyricsData.lyrics, 
            showTranslation ? lyricsData.translation : undefined
          );
          setLyrics(parsed);
        } else {
          setLyrics(null);
          setError('暂无歌词');
        }
      } catch (err) {
        setError('歌词加载失败');
        console.error('Failed to load lyrics:', err);
      } finally {
        setLoading(false);
      }
    };
    
    loadLyrics();
  }, [songId, showTranslation]);
  
  // 更新当前歌词行
  useEffect(() => {
    if (!lyrics) return;
    
    const current = LyricsParser.getCurrentLine(lyrics, currentTime);
    setCurrentLine(current);
  }, [lyrics, currentTime]);
  
  // 自动滚动
  useEffect(() => {
    if (!lyrics || !currentLine || !containerRef.current || !currentLineRef.current) return;
    
    const container = containerRef.current;
    const currentElement = currentLineRef.current;
    
    const containerHeight = container.clientHeight;
    const scrollTop = container.scrollTop;
    const elementTop = currentElement.offsetTop;
    const elementHeight = currentElement.clientHeight;
    
    // 计算是否需要滚动
    const visibleTop = scrollTop;
    const visibleBottom = scrollTop + containerHeight;
    const elementBottom = elementTop + elementHeight;
    
    // 如果当前行不在可视区域中央，滚动到中央
    const centerPosition = elementTop - containerHeight / 2 + elementHeight / 2;
    
    if (elementTop < visibleTop + containerHeight * 0.3 || 
        elementBottom > visibleBottom - containerHeight * 0.3) {
      container.scrollTo({
        top: Math.max(0, centerPosition),
        behavior: 'smooth'
      });
    }
  }, [currentLine]);
  
  if (loading) {
    return (
      <div className={cn('flex items-center justify-center h-32', className)}>
        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-netease"></div>
        <span className="ml-2 text-gray-500">加载歌词中...</span>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className={cn('flex items-center justify-center h-32 text-gray-500', className)}>
        {error}
      </div>
    );
  }
  
  if (!lyrics || !lyrics.lines.length) {
    return (
      <div className={cn('flex items-center justify-center h-32 text-gray-500', className)}>
        暂无歌词
      </div>
    );
  }
  
  const fontSizeClasses = {
    sm: 'text-sm',
    md: 'text-base',
    lg: 'text-lg'
  };
  
  return (
    <div
      ref={containerRef}
      className={cn(
        'overflow-y-auto scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-transparent',
        'max-h-96 px-4 py-8',
        className
      )}
      style={{ lineHeight: `${lineHeight}px` }}
    >
      <div className={cn('space-y-2', centered && 'text-center')}>
        {lyrics.lines.map((line, index) => {
          const isCurrentLine = currentLine?.time === line.time && currentLine?.text === line.text;
          
          return (
            <div
              key={`${line.time}-${index}`}
              ref={isCurrentLine ? currentLineRef : undefined}
              className={cn(
                'transition-all duration-300 cursor-pointer hover:text-netease',
                fontSizeClasses[fontSize],
                isCurrentLine 
                  ? 'text-netease font-medium scale-105' 
                  : 'text-gray-600 hover:text-gray-800'
              )}
              style={{ minHeight: lineHeight }}
              onClick={() => {
                // 点击跳转到对应时间
                const seekTime = line.time / 1000;
                // 这里需要通过props传入onSeek回调
                // onSeek?.(seekTime);
              }}
            >
              <div>{line.text}</div>
              {showTranslation && line.translation && (
                <div className={cn(
                  'text-gray-400 mt-1',
                  fontSize === 'sm' ? 'text-xs' : 'text-sm'
                )}>
                  {line.translation}
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

### 5.2 音频可视化

#### 步骤5.2.1: 创建频谱分析器
创建 `src/components/player/AudioVisualizer.tsx`:
```typescript
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { usePlayerStore } from '../../stores/playerStore';
import { audioService } from '../../services/audio/AudioService';
import { cn } from '../../utils';

interface AudioVisualizerProps {
  type?: 'bars' | 'wave' | 'circle';
  color?: string;
  className?: string;
  height?: number;
  sensitivity?: number;
  smoothing?: number;
}

export const AudioVisualizer: React.FC<AudioVisualizerProps> = ({
  type = 'bars',
  color = '#C62D42',
  className,
  height = 100,
  sensitivity = 1,
  smoothing = 0.8,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>();
  const [isActive, setIsActive] = useState(false);
  
  const { isPlaying } = usePlayerStore();
  
  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    const width = canvas.width;
    const height = canvas.height;
    
    // 获取频谱数据
    const frequencyData = audioService.getFrequencyData();
    
    if (frequencyData.length === 0) {
      // 没有音频数据，绘制静态状态
      ctx.clearRect(0, 0, width, height);
      return;
    }
    
    // 清空画布
    ctx.clearRect(0, 0, width, height);
    
    switch (type) {
      case 'bars':
        drawBars(ctx, frequencyData, width, height, color, sensitivity);
        break;
      case 'wave':
        drawWave(ctx, frequencyData, width, height, color, sensitivity);
        break;
      case 'circle':
        drawCircle(ctx, frequencyData, width, height, color, sensitivity);
        break;
    }
  }, [type, color, sensitivity]);
  
  const animate = useCallback(() => {
    if (!isPlaying || !isActive) {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = undefined;
      }
      return;
    }
    
    draw();
    animationRef.current = requestAnimationFrame(animate);
  }, [isPlaying, isActive, draw]);
  
  // 监听播放状态
  useEffect(() => {
    setIsActive(isPlaying);
  }, [isPlaying]);
  
  // 启动/停止动画
  useEffect(() => {
    if (isActive && isPlaying) {
      animate();
    } else if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = undefined;
      
      // 清空画布
      const canvas = canvasRef.current;
      if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx?.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isActive, isPlaying, animate]);
  
  // 设置canvas尺寸
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const container = canvas.parentElement;
    if (!container) return;
    
    const updateSize = () => {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width * devicePixelRatio;
      canvas.height = height * devicePixelRatio;
      canvas.style.width = `${rect.width}px`;
      canvas.style.height = `${height}px`;
      
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.scale(devicePixelRatio, devicePixelRatio);
      }
    };
    
    updateSize();
    window.addEventListener('resize', updateSize);
    
    return () => window.removeEventListener('resize', updateSize);
  }, [height]);
  
  return (
    <div className={cn('w-full', className)} style={{ height }}>
      <canvas
        ref={canvasRef}
        className="w-full h-full"
        style={{ imageRendering: 'pixelated' }}
      />
    </div>
  );
};

// 绘制柱状图
function drawBars(
  ctx: CanvasRenderingContext2D,
  data: Uint8Array,
  width: number,
  height: number,
  color: string,
  sensitivity: number
) {
  const barCount = Math.min(64, data.length / 4); // 减少柱子数量
  const barWidth = width / barCount;
  
  ctx.fillStyle = color;
  
  for (let i = 0; i < barCount; i++) {
    const dataIndex = Math.floor((i / barCount) * data.length);
    const amplitude = (data[dataIndex] / 255) * sensitivity;
    const barHeight = amplitude * height;
    
    const x = i * barWidth;
    const y = height - barHeight;
    
    // 添加渐变效果
    const gradient = ctx.createLinearGradient(0, y, 0, height);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, color + '60'); // 添加透明度
    
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, barWidth - 2, barHeight);
  }
}

// 绘制波形图
function drawWave(
  ctx: CanvasRenderingContext2D,
  data: Uint8Array,
  width: number,
  height: number,
  color: string,
  sensitivity: number
) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  const sliceWidth = width / data.length;
  let x = 0;
  
  for (let i = 0; i < data.length; i++) {
    const amplitude = (data[i] / 255) * sensitivity;
    const y = height / 2 + (amplitude - 0.5) * height;
    
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
    
    x += sliceWidth;
  }
  
  ctx.stroke();
}

// 绘制圆形可视化
function drawCircle(
  ctx: CanvasRenderingContext2D,
  data: Uint8Array,
  width: number,
  height: number,
  color: string,
  sensitivity: number
) {
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) / 4;
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  
  const barCount = Math.min(60, data.length / 2);
  const angleStep = (Math.PI * 2) / barCount;
  
  for (let i = 0; i < barCount; i++) {
    const dataIndex = Math.floor((i / barCount) * data.length);
    const amplitude = (data[dataIndex] / 255) * sensitivity;
    const barLength = amplitude * radius;
    
    const angle = i * angleStep;
    const x1 = centerX + Math.cos(angle) * radius;
    const y1 = centerY + Math.sin(angle) * radius;
    const x2 = centerX + Math.cos(angle) * (radius + barLength);
    const y2 = centerY + Math.sin(angle) * (radius + barLength);
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
  
  // 绘制中心圆
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
  ctx.fillStyle = color + '40';
  ctx.fill();
}
```

### 5.3 用户数据管理

#### 步骤5.3.1: 创建用户数据存储
创建 `src/stores/userStore.ts`:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Song, Playlist } from '../types';

interface UserState {
  // 用户收藏
  favorites: Song[];
  favoriteSongIds: Set<string>;
  
  // 用户播放列表
  playlists: Playlist[];
  
  // 播放历史
  recentPlayed: Song[];
  
  // 用户设置
  settings: {
    theme: 'light' | 'dark';
    autoPlay: boolean;
    showLyrics: boolean;
    showTranslation: boolean;
    audioQuality: string;
    crossfade: boolean;
    volume: number;
  };
  
  // Actions
  addToFavorites: (song: Song) => void;
  removeFromFavorites: (songId: string) => void;
  isFavorite: (songId: string) => boolean;
  
  createPlaylist: (name: string, description?: string) => Playlist;
  deletePlaylist: (playlistId: string) => void;
  addToPlaylist: (playlistId: string, song: Song) => void;
  removeFromPlaylist: (playlistId: string, songId: string) => void;
  updatePlaylist: (playlistId: string, updates: Partial<Playlist>) => void;
  
  addToRecentPlayed: (song: Song) => void;
  clearRecentPlayed: () => void;
  
  updateSettings: (settings: Partial<UserState['settings']>) => void;
}

export const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      favorites: [],
      favoriteSongIds: new Set(),
      playlists: [],
      recentPlayed: [],
      settings: {
        theme: 'light',
        autoPlay: true,
        showLyrics: true,
        showTranslation: false,
        audioQuality: 'standard',
        crossfade: false,
        volume: 0.8,
      },
      
      // 收藏管理
      addToFavorites: (song: Song) => {
        const state = get();
        if (!state.favoriteSongIds.has(song.id)) {
          set({
            favorites: [song, ...state.favorites],
            favoriteSongIds: new Set([...state.favoriteSongIds, song.id])
          });
        }
      },
      
      removeFromFavorites: (songId: string) => {
        const state = get();
        if (state.favoriteSongIds.has(songId)) {
          const newFavorites = state.favorites.filter(song => song.id !== songId);
          const newFavoriteIds = new Set(state.favoriteSongIds);
          newFavoriteIds.delete(songId);
          
          set({
            favorites: newFavorites,
            favoriteSongIds: newFavoriteIds
          });
        }
      },
      
      isFavorite: (songId: string) => {
        return get().favoriteSongIds.has(songId);
      },
      
      // 播放列表管理
      createPlaylist: (name: string, description = '') => {
        const playlist: Playlist = {
          id: `playlist_${Date.now()}`,
          title: name,
          description,
          coverUrl: '',
          creator: '我',
          songs: [],
          isPublic: false,
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        set(state => ({
          playlists: [...state.playlists, playlist]
        }));
        
        return playlist;
      },
      
      deletePlaylist: (playlistId: string) => {
        set(state => ({
          playlists: state.playlists.filter(p => p.id !== playlistId)
        }));
      },
      
      addToPlaylist: (playlistId: string, song: Song) => {
        set(state => ({
          playlists: state.playlists.map(playlist => {
            if (playlist.id === playlistId) {
              const songExists = playlist.songs.some(s => s.id === song.id);
              if (!songExists) {
                return {
                  ...playlist,
                  songs: [...playlist.songs, song],
                  updatedAt: new Date()
                };
              }
            }
            return playlist;
          })
        }));
      },
      
      removeFromPlaylist: (playlistId: string, songId: string) => {
        set(state => ({
          playlists: state.playlists.map(playlist => {
            if (playlist.id === playlistId) {
              return {
                ...playlist,
                songs: playlist.songs.filter(song => song.id !== songId),
                updatedAt: new Date()
              };
            }
            return playlist;
          })
        }));
      },
      
      updatePlaylist: (playlistId: string, updates: Partial<Playlist>) => {
        set(state => ({
          playlists: state.playlists.map(playlist => {
            if (playlist.id === playlistId) {
              return {
                ...playlist,
                ...updates,
                updatedAt: new Date()
              };
            }
            return playlist;
          })
        }));
      },
      
      // 播放历史管理
      addToRecentPlayed: (song: Song) => {
        set(state => {
          const filtered = state.recentPlayed.filter(s => s.id !== song.id);
          const newRecentPlayed = [song, ...filtered].slice(0, 50); // 保留最近50首
          
          return {
            recentPlayed: newRecentPlayed
          };
        });
      },
      
      clearRecentPlayed: () => {
        set({ recentPlayed: [] });
      },
      
      // 设置管理
      updateSettings: (newSettings: Partial<UserState['settings']>) => {
        set(state => ({
          settings: {
            ...state.settings,
            ...newSettings
          }
        }));
      },
    }),
    {
      name: 'user-store',
      partialize: (state) => ({
        favorites: state.favorites,
        favoriteSongIds: Array.from(state.favoriteSongIds), // Set需要转换为数组
        playlists: state.playlists,
        recentPlayed: state.recentPlayed,
        settings: state.settings,
      }),
      // 恢复时重建Set
      onRehydrateStorage: () => (state) => {
        if (state && Array.isArray(state.favoriteSongIds)) {
          state.favoriteSongIds = new Set(state.favoriteSongIds);
        }
      },
    }
  )
);
```

### 5.4 验收标准

#### 阶段5完成检查清单：
- [ ] ✅ 歌词解析和显示功能正常
- [ ] ✅ 歌词滚动和高亮效果流畅
- [ ] ✅ 音频可视化效果美观
- [ ] ✅ 用户收藏功能完整
- [ ] ✅ 播放列表管理功能正常
- [ ] ✅ 播放历史记录正常
- [ ] ✅ 用户设置持久化正常

---

## 📱 阶段6: 移动端优化 (第12-13周)

### 6.1 响应式布局适配

#### 步骤6.1.1: 创建响应式Hook
创建 `src/hooks/useResponsive.ts`:
```typescript
import { useState, useEffect } from 'react';

export interface BreakpointConfig {
  sm: number;
  md: number;
  lg: number;
  xl: number;
  '2xl': number;
}

const defaultBreakpoints: BreakpointConfig = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  '2xl': 1536,
};

export type ScreenSize = keyof BreakpointConfig;

export interface ResponsiveState {
  screenSize: ScreenSize;
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
  width: number;
  height: number;
}

export const useResponsive = (breakpoints: BreakpointConfig = defaultBreakpoints): ResponsiveState => {
  const [state, setState] = useState<ResponsiveState>(() => {
    if (typeof window === 'undefined') {
      return {
        screenSize: 'lg',
        isMobile: false,
        isTablet: false,
        isDesktop: true,
        width: 1024,
        height: 768,
      };
    }
    
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    return {
      ...getScreenInfo(width, breakpoints),
      width,
      height,
    };
  });
  
  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      setState({
        ...getScreenInfo(width, breakpoints),
        width,
        height,
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [breakpoints]);
  
  return state;
};

function getScreenInfo(width: number, breakpoints: BreakpointConfig) {
  let screenSize: ScreenSize = 'sm';
  
  if (width >= breakpoints['2xl']) {
    screenSize = '2xl';
  } else if (width >= breakpoints.xl) {
    screenSize = 'xl';
  } else if (width >= breakpoints.lg) {
    screenSize = 'lg';
  } else if (width >= breakpoints.md) {
    screenSize = 'md';
  } else {
    screenSize = 'sm';
  }
  
  return {
    screenSize,
    isMobile: width < breakpoints.md,
    isTablet: width >= breakpoints.md && width < breakpoints.lg,
    isDesktop: width >= breakpoints.lg,
  };
}
```

#### 步骤6.1.2: 创建移动端播放器栏
创建 `src/components/player/MobilePlayerBar.tsx`:
```typescript
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Play, Pause, SkipForward, ChevronUp } from 'lucide-react';
import { usePlayerStore } from '../../stores/playerStore';
import { SongInfo } from './SongInfo';
import { Button } from '../common/Button';
import { ProgressBar } from './ProgressBar';
import { cn } from '../../utils';

interface MobilePlayerBarProps {
  onExpandClick?: () => void;
  className?: string;
}

export const MobilePlayerBar: React.FC<MobilePlayerBarProps> = ({
  onExpandClick,
  className,
}) => {
  const {
    currentSong,
    isPlaying,
    currentTime,
    duration,
    play,
    pause,
    next,
    seek,
  } = usePlayerStore();
  
  const [isDragging, setIsDragging] = useState(false);
  
  if (!currentSong) return null;
  
  const handlePlayPause = () => {
    if (isPlaying) {
      pause();
    } else {
      play();
    }
  };
  
  return (
    <motion.div
      initial={{ y: 100 }}
      animate={{ y: 0 }}
      exit={{ y: 100 }}
      className={cn(
        'fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 shadow-lg z-50',
        className
      )}
    >
      {/* 进度条 */}
      <div className="absolute top-0 left-0 right-0 -mt-1">
        <ProgressBar
          currentTime={currentTime}
          duration={duration}
          onSeek={seek}
          onSeekStart={() => setIsDragging(true)}
          onSeekEnd={() => setIsDragging(false)}
          className="px-0"
        />
      </div>
      
      {/* 主控制区域 */}
      <div className="flex items-center p-3 space-x-3">
        {/* 歌曲信息 */}
        <div
          className="flex-1 min-w-0 cursor-pointer"
          onClick={onExpandClick}
        >
          <SongInfo
            song={currentSong}
            size="sm"
            showControls={false}
          />
        </div>
        
        {/* 控制按钮 */}
        <div className="flex items-center space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={handlePlayPause}
            className="text-gray-600 hover:text-gray-900"
          >
            {isPlaying ? (
              <Pause className="w-6 h-6" />
            ) : (
              <Play className="w-6 h-6" />
            )}
          </Button>
          
          <Button
            variant="ghost"
            size="sm"
            onClick={next}
            className="text-gray-600 hover:text-gray-900"
          >
            <SkipForward className="w-5 h-5" />
          </Button>
          
          {onExpandClick && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onExpandClick}
              className="text-gray-600 hover:text-gray-900"
            >
              <ChevronUp className="w-5 h-5" />
            </Button>
          )}
        </div>
      </div>
    </motion.div>
  );
};
```

### 6.2 触摸手势支持

#### 步骤6.2.1: 创建手势Hook
创建 `src/hooks/useGestures.ts`:
```typescript
import { useRef, useEffect, useCallback } from 'react';

export interface GestureState {
  isSwipping: boolean;
  swipeDirection: 'left' | 'right' | 'up' | 'down' | null;
  swipeDistance: number;
  velocity: number;
}

export interface GestureCallbacks {
  onSwipe?: (direction: 'left' | 'right' | 'up' | 'down', distance: number, velocity: number) => void;
  onSwipeStart?: (direction: 'left' | 'right' | 'up' | 'down') => void;
  onSwipeEnd?: () => void;
  onTap?: (x: number, y: number) => void;
  onDoubleTap?: (x: number, y: number) => void;
  onLongPress?: (x: number, y: number) => void;
}

export interface GestureOptions {
  swipeThreshold?: number;
  velocityThreshold?: number;
  longPressDelay?: number;
  doubleTapDelay?: number;
  preventScroll?: boolean;
}

export const useGestures = (
  callbacks: GestureCallbacks,
  options: GestureOptions = {}
) => {
  const elementRef = useRef<HTMLElement>(null);
  const gestureStateRef = useRef<{
    startX: number;
    startY: number;
    currentX: number;
    currentY: number;
    startTime: number;
    isTracking: boolean;
    lastTap: number;
    longPressTimer?: NodeJS.Timeout;
  }>({
    startX: 0,
    startY: 0,
    currentX: 0,
    currentY: 0,
    startTime: 0,
    isTracking: false,
    lastTap: 0,
  });
  
  const {
    swipeThreshold = 50,
    velocityThreshold = 0.3,
    longPressDelay = 500,
    doubleTapDelay = 300,
    preventScroll = false,
  } = options;
  
  const getDistance = useCallback((deltaX: number, deltaY: number) => {
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  }, []);
  
  const getDirection = useCallback((deltaX: number, deltaY: number) => {
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    
    if (absX > absY) {
      return deltaX > 0 ? 'right' : 'left';
    } else {
      return deltaY > 0 ? 'down' : 'up';
    }
  }, []);
  
  const handleTouchStart = useCallback((e: TouchEvent) => {
    if (preventScroll) {
      e.preventDefault();
    }
    
    const touch = e.touches[0];
    const state = gestureStateRef.current;
    
    state.startX = touch.clientX;
    state.startY = touch.clientY;
    state.currentX = touch.clientX;
    state.currentY = touch.clientY;
    state.startTime = Date.now();
    state.isTracking = true;
    
    // 清除之前的长按定时器
    if (state.longPressTimer) {
      clearTimeout(state.longPressTimer);
    }
    
    // 设置长按定时器
    state.longPressTimer = setTimeout(() => {
      if (state.isTracking) {
        const distance = getDistance(
          state.currentX - state.startX,
          state.currentY - state.startY
        );
        
        // 如果没有移动太多，触发长按
        if (distance < swipeThreshold / 2) {
          callbacks.onLongPress?.(state.startX, state.startY);
        }
      }
    }, longPressDelay);
  }, [callbacks, preventScroll, swipeThreshold, longPressDelay, getDistance]);
  
  const handleTouchMove = useCallback((e: TouchEvent) => {
    if (preventScroll) {
      e.preventDefault();
    }
    
    const touch = e.touches[0];
    const state = gestureStateRef.current;
    
    if (!state.isTracking) return;
    
    state.currentX = touch.clientX;
    state.currentY = touch.clientY;
    
    const deltaX = state.currentX - state.startX;
    const deltaY = state.currentY - state.startY;
    const distance = getDistance(deltaX, deltaY);
    
    // 如果移动距离超过阈值，取消长按
    if (distance > swipeThreshold / 2 && state.longPressTimer) {
      clearTimeout(state.longPressTimer);
      state.longPressTimer = undefined;
    }
    
    // 如果移动距离超过滑动阈值，开始滑动
    if (distance > swipeThreshold) {
      const direction = getDirection(deltaX, deltaY);
      callbacks.onSwipeStart?.(direction);
    }
  }, [callbacks, preventScroll, swipeThreshold, getDistance, getDirection]);
  
  const handleTouchEnd = useCallback((e: TouchEvent) => {
    if (preventScroll) {
      e.preventDefault();
    }
    
    const state = gestureStateRef.current;
    
    if (!state.isTracking) return;
    
    const endTime = Date.now();
    const deltaTime = endTime - state.startTime;
    const deltaX = state.currentX - state.startX;
    const deltaY = state.currentY - state.startY;
    const distance = getDistance(deltaX, deltaY);
    const velocity = distance / deltaTime;
    
    // 清除长按定时器
    if (state.longPressTimer) {
      clearTimeout(state.longPressTimer);
      state.longPressTimer = undefined;
    }
    
    state.isTracking = false;
    
    // 判断是否为滑动
    if (distance > swipeThreshold || velocity > velocityThreshold) {
      const direction = getDirection(deltaX, deltaY);
      callbacks.onSwipe?.(direction, distance, velocity);
      callbacks.onSwipeEnd?.();
    } else {
      // 判断是否为点击或双击
      const now = Date.now();
      const timeSinceLastTap = now - state.lastTap;
      
      if (timeSinceLastTap < doubleTapDelay) {
        // 双击
        callbacks.onDoubleTap?.(state.startX, state.startY);
        state.lastTap = 0; // 重置以避免三击
      } else {
        // 单击
        callbacks.onTap?.(state.startX, state.startY);
        state.lastTap = now;
      }
    }
  }, [
    callbacks,
    preventScroll,
    swipeThreshold,
    velocityThreshold,
    doubleTapDelay,
    getDistance,
    getDirection,
  ]);
  
  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;
    
    element.addEventListener('touchstart', handleTouchStart, { passive: !preventScroll });
    element.addEventListener('touchmove', handleTouchMove, { passive: !preventScroll });
    element.addEventListener('touchend', handleTouchEnd, { passive: !preventScroll });
    
    return () => {
      element.removeEventListener('touchstart', handleTouchStart);
      element.removeEventListener('touchmove', handleTouchMove);
      element.removeEventListener('touchend', handleTouchEnd);
      
      // 清理定时器
      const state = gestureStateRef.current;
      if (state.longPressTimer) {
        clearTimeout(state.longPressTimer);
      }
    };
  }, [handleTouchStart, handleTouchMove, handleTouchEnd, preventScroll]);
  
  return elementRef;
};
```

### 6.3 PWA功能实现

#### 步骤6.3.1: 创建Service Worker
创建 `public/sw.js`:
```javascript
const CACHE_NAME = 'netease-music-player-v1.0.0';
const STATIC_CACHE = 'static-cache-v1';
const DYNAMIC_CACHE = 'dynamic-cache-v1';
const AUDIO_CACHE = 'audio-cache-v1';
const IMAGE_CACHE = 'image-cache-v1';

// 需要缓存的静态资源
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json',
  '/favicon.ico',
];

// 安装事件
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        return self.skipWaiting();
      })
  );
});

// 激活事件
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== STATIC_CACHE && 
                cacheName !== DYNAMIC_CACHE && 
                cacheName !== AUDIO_CACHE &&
                cacheName !== IMAGE_CACHE) {
              console.log('Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        return self.clients.claim();
      })
  );
});

// 获取事件
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // 跳过非 GET 请求
  if (request.method !== 'GET') {
    return;
  }
  
  // 音频文件缓存策略
  if (request.url.includes('audio') || 
      request.url.includes('.mp3') || 
      request.url.includes('.flac') ||
      request.url.includes('.wav')) {
    event.respondWith(handleAudioRequest(request));
    return;
  }
  
  // 图片文件缓存策略
  if (request.url.includes('image') || 
      request.url.includes('.jpg') || 
      request.url.includes('.png') ||
      request.url.includes('.webp') ||
      request.url.includes('.gif')) {
    event.respondWith(handleImageRequest(request));
    return;
  }
  
  // 静态资源缓存策略
  if (STATIC_ASSETS.some(asset => request.url.includes(asset))) {
    event.respondWith(handleStaticRequest(request));
    return;
  }
  
  // API请求缓存策略
  if (request.url.includes('/api/')) {
    event.respondWith(handleAPIRequest(request));
    return;
  }
  
  // 默认网络优先策略
  event.respondWith(handleNetworkFirst(request));
});

// 处理音频请求 - 缓存优先
async function handleAudioRequest(request) {
  try {
    const cache = await caches.open(AUDIO_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      console.log('Audio cache hit:', request.url);
      return cachedResponse;
    }
    
    console.log('Audio cache miss, fetching:', request.url);
    const response = await fetch(request);
    
    if (response.ok) {
      // 检查缓存大小限制
      const cacheSize = await getCacheSize(AUDIO_CACHE);
      const maxSize = 100 * 1024 * 1024; // 100MB
      
      if (cacheSize < maxSize) {
        cache.put(request, response.clone());
      } else {
        // 清理最旧的缓存
        await cleanupOldCache(AUDIO_CACHE, 0.7); // 清理30%的缓存
        cache.put(request, response.clone());
      }
    }
    
    return response;
  } catch (error) {
    console.error('Audio request failed:', error);
    return new Response('Audio not available offline', { 
      status: 503,
      statusText: 'Service Unavailable' 
    });
  }
}

// 处理图片请求 - 缓存优先
async function handleImageRequest(request) {
  try {
    const cache = await caches.open(IMAGE_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    const response = await fetch(request);
    
    if (response.ok) {
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.error('Image request failed:', error);
    // 返回默认图片
    return new Response('', { status: 404 });
  }
}

// 处理静态资源 - 缓存优先
async function handleStaticRequest(request) {
  try {
    const cache = await caches.open(STATIC_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    const response = await fetch(request);
    
    if (response.ok) {
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.error('Static request failed:', error);
    return cache.match('/index.html'); // 返回离线页面
  }
}

// 处理API请求 - 网络优先，缓存备用
async function handleAPIRequest(request) {
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.log('API request failed, trying cache:', request.url);
    const cache = await caches.open(DYNAMIC_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    return new Response(JSON.stringify({ 
      error: 'Offline',
      message: 'No network connection and no cached data available' 
    }), {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// 网络优先策略
async function handleNetworkFirst(request) {
  try {
    const response = await fetch(request);
    return response;
  } catch (error) {
    const cache = await caches.open(DYNAMIC_CACHE);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    return new Response('Offline', { status: 503 });
  }
}

// 获取缓存大小
async function getCacheSize(cacheName) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  let totalSize = 0;
  
  for (const key of keys) {
    const response = await cache.match(key);
    if (response) {
      const blob = await response.blob();
      totalSize += blob.size;
    }
  }
  
  return totalSize;
}

// 清理旧缓存
async function cleanupOldCache(cacheName, ratio = 0.3) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  const deleteCount = Math.floor(keys.length * ratio);
  
  // 删除最旧的缓存项（这里简单按索引删除，实际应该按时间戳）
  for (let i = 0; i < deleteCount; i++) {
    await cache.delete(keys[i]);
  }
}

// 监听消息事件
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'CACHE_AUDIO') {
    const { url } = event.data;
    caches.open(AUDIO_CACHE)
      .then(cache => cache.add(url))
      .catch(error => console.error('Failed to cache audio:', error));
  }
});
```

### 6.4 验收标准

#### 阶段6完成检查清单：
- [ ] ✅ 移动端布局适配完整
- [ ] ✅ 触摸手势支持正常
- [ ] ✅ PWA功能实现完整
- [ ] ✅ 离线缓存策略有效
- [ ] ✅ 移动端性能优化完成
- [ ] ✅ 跨设备兼容性测试通过

---

## 🧪 阶段7: 测试与优化 (第14-15周)

### 7.1 单元测试

#### 步骤7.1.1: 配置测试环境
```bash
# 安装测试依赖
npm install -D @testing-library/react @testing-library/jest-dom @testing-library/user-event
npm install -D vitest jsdom @vitest/ui
npm install -D @types/jest
```

创建 `vitest.config.ts`:
```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
  },
});
```

#### 步骤7.1.2: 创建测试用例
创建 `src/services/audio/__tests__/AudioService.test.ts`:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { AudioService } from '../AudioService';
import { Song, MusicSource, AudioQuality } from '../../../types';

// Mock AudioContext
Object.defineProperty(window, 'AudioContext', {
  writable: true,
  value: vi.fn().mockImplementation(() => ({
    createGain: vi.fn(() => ({ connect: vi.fn() })),
    createAnalyser: vi.fn(() => ({ connect: vi.fn() })),
    createMediaElementSource: vi.fn(() => ({ connect: vi.fn() })),
    destination: {},
    resume: vi.fn(),
  })),
});

const mockSong: Song = {
  id: 'test-song-1',
  title: 'Test Song',
  artist: 'Test Artist',
  album: 'Test Album',
  duration: 180,
  coverUrl: 'https://example.com/cover.jpg',
  audioUrl: 'https://example.com/audio.mp3',
  source: MusicSource.LOCAL,
  quality: AudioQuality.STANDARD
};

describe('AudioService', () => {
  let audioService: AudioService;
  
  beforeEach(() => {
    audioService = new AudioService();
  });
  
  it('should initialize properly', () => {
    expect(audioService).toBeDefined();
  });
  
  it('should add song to queue', () => {
    audioService.addToQueue(mockSong);
    const queue = audioService.getQueue();
    
    expect(queue).toHaveLength(1);
    expect(queue[0]).toEqual(mockSong);
  });
  
  it('should remove song from queue', () => {
    audioService.addToQueue(mockSong);
    audioService.removeFromQueue(0);
    
    expect(audioService.getQueue()).toHaveLength(0);
  });
  
  it('should set and get volume', () => {
    audioService.setVolume(0.5);
    // Note: 实际测试中需要mock音频引擎的状态
  });
});
```

### 7.2 集成测试

#### 步骤7.2.1: 组件集成测试
创建 `src/components/player/__tests__/PlayControls.test.tsx`:
```typescript
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { PlayControls } from '../PlayControls';
import { PlayMode } from '../../../types';

describe('PlayControls', () => {
  const defaultProps = {
    isPlaying: false,
    playMode: PlayMode.SEQUENCE,
    onPlay: vi.fn(),
    onPause: vi.fn(),
    onNext: vi.fn(),
    onPrevious: vi.fn(),
    onShuffle: vi.fn(),
    onPlayModeChange: vi.fn(),
  };
  
  it('should render play button when not playing', () => {
    render(<PlayControls {...defaultProps} />);
    
    const playButton = screen.getByTitle('播放');
    expect(playButton).toBeInTheDocument();
  });
  
  it('should render pause button when playing', () => {
    render(<PlayControls {...defaultProps} isPlaying={true} />);
    
    const pauseButton = screen.getByTitle('暂停');
    expect(pauseButton).toBeInTheDocument();
  });
  
  it('should call onPlay when play button is clicked', () => {
    const onPlay = vi.fn();
    render(<PlayControls {...defaultProps} onPlay={onPlay} />);
    
    const playButton = screen.getByTitle('播放');
    fireEvent.click(playButton);
    
    expect(onPlay).toHaveBeenCalledTimes(1);
  });
  
  it('should call onNext when next button is clicked', () => {
    const onNext = vi.fn();
    render(<PlayControls {...defaultProps} onNext={onNext} />);
    
    const nextButton = screen.getByTitle('下一首');
    fireEvent.click(nextButton);
    
    expect(onNext).toHaveBeenCalledTimes(1);
  });
});
```

### 7.3 性能测试

#### 步骤7.3.1: 性能监控工具
创建 `src/utils/performance.ts`:
```typescript
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();
  private observers: PerformanceObserver[] = [];
  
  constructor() {
    this.setupObservers();
  }
  
  private setupObservers() {
    // 监控导航性能
    if ('PerformanceObserver' in window) {
      const navObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          this.recordMetric('navigation', entry.duration);
        });
      });
      
      navObserver.observe({ entryTypes: ['navigation'] });
      this.observers.push(navObserver);
      
      // 监控资源加载性能
      const resourceObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.name.includes('.mp3') || entry.name.includes('audio')) {
            this.recordMetric('audio-load', entry.duration);
          } else if (entry.name.includes('.jpg') || entry.name.includes('.png')) {
            this.recordMetric('image-load', entry.duration);
          }
        });
      });
      
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);
    }
  }
  
  // 记录自定义性能指标
  recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    
    this.metrics.get(name)!.push(value);
    
    // 保持最近100个记录
    const values = this.metrics.get(name)!;
    if (values.length > 100) {
      values.shift();
    }
  }
  
  // 测量函数执行时间
  measure<T>(name: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    this.recordMetric(name, end - start);
    return result;
  }
  
  // 测量异步函数执行时间
  async measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    
    this.recordMetric(name, end - start);
    return result;
  }
  
  // 获取性能统计
  getStats(name: string) {
    const values = this.metrics.get(name) || [];
    
    if (values.length === 0) {
      return null;
    }
    
    const sorted = [...values].sort((a, b) => a - b);
    const sum = values.reduce((a, b) => a + b, 0);
    
    return {
      count: values.length,
      average: sum / values.length,
      median: sorted[Math.floor(sorted.length / 2)],
      min: Math.min(...values),
      max: Math.max(...values),
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }
  
  // 获取所有性能指标
  getAllStats() {
    const stats: Record<string, any> = {};
    
    for (const [name] of this.metrics) {
      stats[name] = this.getStats(name);
    }
    
    return stats;
  }
  
  // 清理资源
  dispose() {
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    this.metrics.clear();
  }
}

// 单例性能监控器
export const performanceMonitor = new PerformanceMonitor();

// 性能装饰器
export function measurePerformance(name: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
      return performanceMonitor.measure(`${target.constructor.name}.${propertyName}`, 
        () => method.apply(this, args)
      );
    };
    
    return descriptor;
  };
}
```

### 7.4 部署与发布

#### 步骤7.4.1: 构建优化配置
更新 `vite.config.ts`:
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\./,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              cacheableResponse: {
                statuses: [0, 200]
              }
            }
          },
          {
            urlPattern: /\.(mp3|flac|wav)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'audio-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 7 * 24 * 60 * 60 // 7 days
              }
            }
          }
        ]
      },
      manifest: {
        name: '网易云音乐播放器',
        short_name: '音乐播放器',
        description: '一个仿网易云音乐的在线播放器',
        theme_color: '#C62D42',
        background_color: '#ffffff',
        display: 'standalone',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      }
    })
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          audio: ['./src/services/audio'],
          ui: ['lucide-react', 'framer-motion']
        }
      }
    },
    sourcemap: true,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  },
  define: {
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version)
  }
});
```

### 7.5 验收标准

#### 阶段7完成检查清单：
- [ ] ✅ 单元测试覆盖率 > 80%
- [ ] ✅ 集成测试通过
- [ ] ✅ 性能指标符合要求
- [ ] ✅ 跨浏览器兼容性测试通过
- [ ] ✅ 移动端测试通过
- [ ] ✅ PWA功能测试通过
- [ ] ✅ 构建优化完成

---

## 🚀 阶段8: 部署与发布 (第16周)

### 8.1 生产环境部署

#### 步骤8.1.1: 创建部署脚本
创建 `scripts/deploy.sh`:
```bash
#!/bin/bash

# 网易云音乐播放器部署脚本

set -e

echo "🚀 Starting deployment process..."

# 检查环境
if [ -z "$NODE_ENV" ]; then
  export NODE_ENV=production
fi

echo "📦 Building application..."
npm run build

echo "🔍 Running post-build checks..."
npm run lint
npm run test:coverage

echo "📊 Analyzing bundle size..."
npm run analyze

echo "🌐 Deploying to production..."

# 部署到Vercel (示例)
if [ "$DEPLOY_TARGET" = "vercel" ]; then
  vercel --prod
fi

# 部署到Netlify (示例)
if [ "$DEPLOY_TARGET" = "netlify" ]; then
  netlify deploy --prod --dir=dist
fi

echo "✅ Deployment completed successfully!"
```

#### 步骤8.1.2: 环境配置
创建 `.env.production`:
```env
VITE_APP_TITLE=网易云音乐播放器
VITE_API_BASE_URL=https://api.example.com
VITE_SENTRY_DSN=your_sentry_dsn
VITE_ANALYTICS_ID=your_analytics_id
```

### 8.2 监控与日志

#### 步骤8.2.1: 错误监控
```bash
npm install @sentry/react @sentry/tracing
```

创建 `src/utils/monitoring.ts`:
```typescript
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/tracing';

export function initializeMonitoring() {
  if (import.meta.env.PROD && import.meta.env.VITE_SENTRY_DSN) {
    Sentry.init({
      dsn: import.meta.env.VITE_SENTRY_DSN,
      environment: import.meta.env.MODE,
      integrations: [
        new BrowserTracing({
          tracingOrigins: ['localhost', /^\//],
        }),
      ],
      tracesSampleRate: 0.1,
      beforeSend(event, hint) {
        // 过滤掉开发环境的错误
        if (import.meta.env.DEV) {
          return null;
        }
        return event;
      },
    });
  }
}

export function captureException(error: Error, context?: any) {
  if (import.meta.env.PROD) {
    Sentry.captureException(error, context);
  } else {
    console.error('Error:', error, context);
  }
}
```

### 8.3 最终验收

#### 完整项目验收清单：

##### 功能完整性 ✅
- [ ] ✅ 音乐播放、暂停、停止
- [ ] ✅ 播放队列管理
- [ ] ✅ 音量控制
- [ ] ✅ 播放模式切换
- [ ] ✅ 进度控制
- [ ] ✅ 歌曲搜索
- [ ] ✅ 歌词显示
- [ ] ✅ 用户收藏
- [ ] ✅ 播放历史
- [ ] ✅ 音频可视化

##### 技术要求 ✅
- [ ] ✅ React 18 + TypeScript
- [ ] ✅ 响应式设计
- [ ] ✅ PWA支持
- [ ] ✅ 离线功能
- [ ] ✅ 性能优化
- [ ] ✅ 错误处理
- [ ] ✅ 测试覆盖

##### 用户体验 ✅
- [ ] ✅ 界面美观
- [ ] ✅ 交互流畅
- [ ] ✅ 加载迅速
- [ ] ✅ 移动端适配
- [ ] ✅ 触摸手势
- [ ] ✅ 无障碍支持

---

## 📋 总结

这份详细的开发实施方案涵盖了网易云音乐播放器的完整开发流程：

### 🎯 核心成果
1. **完整的音频播放系统** - 支持多种音频格式和播放模式
2. **现代化的用户界面** - 响应式设计，移动端优化
3. **高性能优化** - 代码分割、缓存策略、虚拟滚动
4. **PWA应用** - 离线支持、安装到桌面
5. **完善的测试覆盖** - 单元测试、集成测试、性能测试

### 🛠 技术亮点
- **Web Audio API** 专业音频处理
- **Zustand** 轻量级状态管理
- **IndexedDB** 本地数据持久化
- **Service Worker** 离线缓存策略
- **Framer Motion** 流畅动画效果

### 📈 开发进度
- **总计16周** 完整开发周期
- **8个阶段** 循序渐进实施
- **详细验收标准** 确保质量交付

这个方案提供了从项目初始化到最终部署的完整指导，每个步骤都有具体的代码实现和验收标准，确保开发团队能够高效、高质量地完成项目交付。